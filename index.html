// Function to create text texture
        function createTextTexture() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Add roundRect polyfill if not available
            if (!ctx.roundRect) {
                ctx.roundRect = function(x, y, width, height, radius) {
                    this.beginPath();
                    this.moveTo(x + radius, y);
                    this.lineTo(x + width - radius, y);
                    this.quadraticCurveTo(x + width, y, x + width, y + radius);
                    this.lineTo(x + width, y + height - radius);
                    this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    this.lineTo(x + radius, y + height);
                    this.quadraticCurveTo(x, y + height, x, y + height - radius);
                    this.lineTo(x, y + radius);
                    this.quadraticCurveTo(x, y, x + radius, y);
                    this.closePath();
                };
            }
            
            // Set canvas size to match window
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get hero section bounds
            const heroSection = document.querySelector('.hero-section');
            const heroContent = document.querySelector('.hero-content');
            const heroTitle = document.querySelector('.hero-title');
            const heroSubtitle = document.querySelector('.hero-subtitle');
            const ctaButton = document.querySelector('.cta-button');
            
            if (!heroSection || !heroContent) return null;
            
            const heroRect = heroSection.getBoundingClientRect();
            const contentRect = heroContent.getBoundingClientRect();
            
            // Set text properties
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Calculate responsive font sizes based on window size
            const baseFontSize = Math.min(window.innerWidth * 0.08, 96);
            const subtitleFontSize = Math.min(window.innerWidth * 0.024, 24);
            const buttonFontSize = Math.min(window.innerWidth * 0.018, 18);
            
            // Position text to match the hero section layout
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw main title
            ctx.font = `bold ${baseFontSize}px Arial`;
            const titleY = centerY - 60;
            ctx.fillText('Interactive 4D Hypercube', centerX, titleY);
            
            // Draw subtitle
            ctx.font = `${subtitleFontSize}px Arial`;
            const subtitleY = titleY + baseFontSize * 0.8 + 20;
            ctx.fillText('Explore higher dimensions through immersive visualization', centerX, subtitleY);
            
            // Draw CTA button outline (we'll make it hollow so light can go through)
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.font = `${buttonFontSize}px Arial`;
            
            const buttonText = 'Start Learning';
            const buttonMetrics = ctx.measureText(buttonText);
            const buttonWidth = buttonMetrics.width + 60;
            const buttonHeight = 50;
            const buttonY = subtitleY + subtitleFontSize + 60;
            const buttonX = centerX;
            
            // Draw button border
            ctx.beginPath();
            ctx.roundRect(buttonX - buttonWidth/2, buttonY - buttonHeight/2, buttonWidth, buttonHeight, 25);
            ctx.stroke();
            
            // Draw button text
            ctx.fillText(buttonText, buttonX, buttonY);
            
            return canvas;
        }

        function initHypercube() {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('hypercube-canvas'),
                alpha: true,
                antialias: false // Disable for better performance
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Create vertex texture
            const vertexData = new Float32Array(33 * 4);
            hypercubeVertices.forEach((vertex, i) => {
                vertexData[i * 4] = (vertex[0] - 0.5) * 2; // Center and scale
                vertexData[i * 4 + 1] = (vertex[1] - 0.5) * 2;
                vertexData[i * 4 + 2] = (vertex[2] - 0.5) * 2;
                vertexData[i * 4 + 3] = (vertex[3] - 0.5) * 2;
            });
            
            const vertexTexture = new THREE.DataTexture(
                vertexData, 33, 1, THREE.RGBAFormat, THREE.FloatType
            );
            vertexTexture.needsUpdate = true;
            
            // Create text texture
            const textCanvas = createTextTexture();
            let textTexture = null;
            if (textCanvas) {
                textTexture = new THREE.CanvasTexture(textCanvas);
                textTexture.needsUpdate = true;
            } else {
                // Create a blank texture as fallback
                const blankCanvas = document.createElement('canvas');
                blankCanvas.width = window.innerWidth;
                blankCanvas.height = window.innerHeight;
                textTexture = new THREE.CanvasTexture(blankCanvas);
            }
