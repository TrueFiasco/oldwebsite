<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tesseract Tutorial - Interactive TouchDesigner Guide</title>
  <style>
    @font-face {
      font-family: 'Spy Agency';
      src: url('./fonts/spyagencycond.ttf') format('truetype');
      font-weight: normal;
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Orbitron';
      src: url('./fonts/Orbitron-Regular.ttf') format('truetype');
      font-weight: 400;
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Orbitron';
      src: url('./fonts/Orbitron-Medium.ttf') format('truetype');
      font-weight: 500;
      font-display: swap;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #ffffff;
      overflow-x: hidden;
    }

    /* Hero Section */
    .hero-section {
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
      cursor: pointer;
      transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      position: relative;
      overflow: hidden;
    }

    .hero-section:hover {
      transform: scale(1.02);
    }

    .hero-content {
      text-align: center;
      z-index: 2;
      pointer-events: none;
      opacity: 0;
      display: none; /* Completely hide hero content */
    }

    .hero-title {
      font-family: 'Spy Agency', 'Arial', sans-serif;
      font-size: clamp(3.75rem, 12vw, 9rem);
      font-weight: normal;
      margin-bottom: 1rem;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientShift 3s ease-in-out infinite;
      opacity: 0;
    }

    .hero-subtitle {
      font-family: 'Orbitron', 'Arial', sans-serif;
      font-size: 2.25rem;
      margin-bottom: 2rem;
      opacity: 0;
      line-height: 1.2;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .hypercube-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* Settings Toggle for Hero */
    .hero-settings-toggle {
      position: fixed;
      top: 2rem;
      left: 2rem;
      z-index: 100;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      pointer-events: auto;
    }

    .hero-settings-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.5);
      transform: rotate(90deg);
    }

    .hero-settings-toggle svg {
      width: 24px;
      height: 24px;
      fill: #ffffff;
    }

    /* Hero Controls Panel */
    .hero-controls-panel {
      position: fixed;
      top: 2rem;
      left: 2rem;
      z-index: 99;
      background: rgba(0, 0, 0, 0.8);
      padding: 1.5rem;
      border-radius: 15px;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      font-size: 0.9rem;
      min-width: 280px;
      display: none;
      pointer-events: auto;
    }

    .hero-controls-panel h4 {
      color: #4ecdc4;
      margin-bottom: 1rem;
      text-align: center;
    }

    .control-group {
      margin-bottom: 0.8rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .control-group label {
      color: #ffffff;
      font-size: 0.85rem;
      min-width: 80px;
    }

    .control-group input {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      color: white;
      padding: 0.3rem 0.5rem;
      font-size: 0.8rem;
      width: 80px;
      text-align: center;
    }

    .control-group input:focus {
      outline: none;
      border-color: #4ecdc4;
      background: rgba(255, 255, 255, 0.15);
    }

    .info-section {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }

    .info-section h4 {
      color: #4ecdc4;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .info-section p {
      margin-bottom: 0.3rem;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.4;
    }

    /* Tutorial Container */
    .tutorial-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      z-index: 1000;
      transform: translateY(100%);
      transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      display: flex;
      flex-direction: column;
    }

    .tutorial-container.active {
      transform: translateY(0);
    }

    /* Tutorial Header */
    .tutorial-header {
      background: #1a1a2e;
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      position: relative;
      z-index: 2000;
      min-height: 60px;
      gap: 1rem;
    }

    .tutorial-title {
      font-size: clamp(1.2rem, 3vw, 2rem);
      color: #00ffff;
      font-weight: bold;
      flex: 1;
      max-width: 65%;
      line-height: 1.3;
      margin-right: 1rem;
      overflow-wrap: break-word;
      hyphens: auto;
      word-break: break-word;
    }

    .tutorial-nav {
      display: flex;
      gap: 1rem;
      align-items: flex-start;
      justify-content: flex-end;
      flex-shrink: 0;
      flex-wrap: wrap;
    }

    .nav-btn {
      background: #333;
      border: none;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      font-size: 0.9rem;
    }

    .nav-btn:hover {
      background: #555;
    }

    .nav-btn.primary {
      background: #00ffff;
      color: #000;
    }

    .nav-btn.primary:hover {
      background: #33ffff;
    }

    .nav-btn.circular {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      min-width: 40px;
      flex-shrink: 0;
    }

    .close-btn {
      background: #ff4757;
      font-size: 1.2rem;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      min-width: 35px;
      flex-shrink: 0;
    }

    /* Tutorial Content */
    .tutorial-content {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    .tutorial-scroller {
      display: flex;
      height: 100%;
      transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      will-change: transform;
    }

    .tutorial-section {
      min-width: 100vw;
      min-height: calc(100vh - 60px);
      padding: 0.5rem 2rem 2rem 2rem;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow-y: auto;
      background: linear-gradient(180deg, #1a1a2e 0%, #191b1f 50%, #191b1f 100%);
      z-index: 5;
    }

    .tutorial-section.has-background-image {
      padding-bottom: 360px;
    }

    .section-layout {
      display: flex;
      gap: 2rem;
      flex: 1;
      z-index: 20;
      position: relative;
      margin-top: 0.25rem;
      margin-bottom: 2rem;
    }

    .section-left {
      flex: 2;
      display: flex;
      flex-direction: column;
      z-index: 20;
      position: relative;
      min-width: 0;
    }

    .section-right {
      flex: 1;
      display: flex;
      flex-direction: column;
      z-index: 20;
      position: relative;
      min-width: 0;
      padding-top: 0.05rem;
    }

    .section-full {
      width: 100%;
      display: flex;
      flex-direction: column;
      margin-top: 1rem;
      margin-bottom: 2rem;
      z-index: 20;
      position: relative;
    }

    /* Static Image Container */
    .static-image-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 400px;
      background: rgb(25, 27, 31);
      border-radius: 10px 10px 0 0;
      overflow: hidden;
      z-index: 1;
    }

    .image-transition-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: 1;
    }

    .tutorial-image {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      z-index: 1;
    }

    /* Hotspot System */
    .hotspot {
      position: absolute;
      width: 30px;
      height: 30px;
      background: #00ffff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 22px rgba(0, 255, 255, 0.7);
      animation: pulse 2s infinite;
      border: 3px solid rgba(255, 255, 255, 0.3);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      z-index: 50;
      pointer-events: auto;
    }

    .hotspot:hover, .hotspot.sticky {
      transform: scale(1.3);
      background: #ff00ff;
      box-shadow: 0 0 35px rgba(255, 0, 255, 0.8);
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
    }

    /* Parameter Dialog */
    .parameter-dialog {
      position: fixed;
      background: #1a1a2e;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 1rem;
      max-width: 600px;
      min-width: 300px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.8);
      z-index: 3000;
      display: none;
      pointer-events: auto;
    }

    .parameter-dialog.active {
      display: block;
    }

    .parameter-dialog img {
      width: 100%;
      max-width: 525px;
      border-radius: 5px;
      margin-top: 0.5rem;
    }

    .parameter-item {
      margin: 0.5rem 0;
      padding: 0.3rem;
      background: #333;
      border-radius: 3px;
      font-family: monospace;
      font-size: 0.9rem;
    }

    /* Mobile Parameters */
    .mobile-parameters {
      display: none;
      margin: 2rem 0;
      padding: 1.5rem;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      z-index: 25;
      position: relative;
      clear: both;
    }

    .mobile-parameters img {
      width: 100%;
      border-radius: 5px;
      margin-bottom: 1.5rem;
    }

    .mobile-parameters:last-child {
      margin-bottom: 3rem;
    }

    /* Widget System */
    .widget-container {
      display: flex;
      align-items: stretch;
      margin: 0.25rem 0 2rem 0;
      height: auto;
      max-height: 40vh;
      min-height: 300px;
      width: 100%;
      z-index: 25;
      position: relative;
    }

    .widget-buttons {
      display: flex;
      flex-direction: column;
      gap: 1px;
      margin-right: 0.5rem;
      align-self: flex-start;
      padding-top: 0.25rem;
    }

    .widget-btn {
      background: #444;
      border: 1px solid #666;
      color: #ddd;
      padding: 0;
      width: 27px;
      height: 27px;
      cursor: pointer;
      font-size: 1.05rem;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .widget-btn:hover {
      background: #555;
      border-color: #777;
    }

    .widget-btn:active {
      background: #333;
    }

    .widget-btn-fullscreen::before {
      content: '⛶';
      font-size: 15px;
    }

    .widget-btn-copy::before {
      content: '📋';
      font-size: 12px;
    }

    .widget-btn-github::before {
      content: '⬇';
      font-size: 15px;
    }

    .content-widget {
      background: #2a2a2a;
      border-radius: 8px;
      padding: 0;
      border: 1px solid #555;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 100%;
    }

    .content-widget:hover {
      border-color: #777;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
    }

    .widget-header {
      background: #3a3a3a;
      padding: 0.5rem;
      border-top: 1px solid #555;
      position: relative;
      display: flex;
      align-items: center;
      height: 32px;
      order: 2;
    }

    .widget-title {
      font-size: 0.9rem;
      color: #ddd;
      font-weight: normal;
      margin: 0;
      padding-left: 0.5rem;
      flex: 1;
    }

    .widget-content {
      flex: 1;
      overflow: hidden;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.8rem;
      line-height: 1.2;
      background: #2a2a2a;
      color: #ddd;
      position: relative;
      order: 1;
    }

    /* TSV Table */
    .tsv-table {
      width: 100%;
      height: 100%;
      border-collapse: collapse;
      background: #2a2a2a;
    }

    .tsv-table th,
    .tsv-table td {
      border: 1px solid #555;
      padding: 2px 6px;
      text-align: left;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.75rem;
      line-height: 1.2;
      min-width: 40px;
      max-width: 60px;
      overflow: hidden;
    }

    .tsv-table th {
      background: #3a3a3a;
      color: #fff;
      font-weight: bold;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .tsv-table td {
      background: #2a2a2a;
      color: #ddd;
    }

    .tsv-table tr:nth-child(even) td {
      background: #2e2e2e;
    }

    .tsv-table tr:hover td {
      background: #353535;
    }

    /* Code Content */
    .code-content {
      padding: 1rem;
      height: 100%;
      overflow: hidden;
      white-space: pre;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.75rem;
      line-height: 1.3;
      color: #ddd;
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #888;
      font-style: italic;
    }

    .error {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #ff6b6b;
      font-style: italic;
    }

    /* Fullscreen Modals */
    .widget-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      z-index: 4000;
      display: none;
      flex-direction: column;
    }

    .widget-fullscreen.active {
      display: flex;
      animation: fadeInScale 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .widget-fullscreen-header {
      background: #2a2a2a;
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #555;
      min-height: 60px;
      gap: 1rem;
    }

    .widget-fullscreen-header h3 {
      color: #ddd;
      font-size: 1.2rem;
      margin: 0;
      font-weight: normal;
      flex: 1;
    }

    .widget-fullscreen-buttons {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .widget-fullscreen-content {
      flex: 1;
      overflow: auto;
      padding: 0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.4;
      color: #ddd;
      font-size: 0.9rem;
      background: #2a2a2a;
      min-height: 0;
    }

    .widget-fullscreen-content .tsv-table {
      font-size: 0.85rem;
      width: 100%;
      border-collapse: collapse;
    }

    .widget-fullscreen-content .tsv-table th,
    .widget-fullscreen-content .tsv-table td {
      padding: 4px 8px;
      min-width: 60px;
      border: 1px solid #555;
    }

    .widget-fullscreen-content .tsv-table th {
      position: sticky;
      top: 0;
      background: #3a3a3a;
      z-index: 10;
    }

    .widget-fullscreen-content .code-content {
      padding: 2rem;
      font-size: 0.9rem;
      line-height: 1.4;
      height: auto !important;
      overflow: visible !important;
      white-space: pre-wrap;
    }

    .widget-fullscreen-content::-webkit-scrollbar {
      width: 12px;
    }

    .widget-fullscreen-content::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    .widget-fullscreen-content::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 6px;
    }

    .widget-fullscreen-content::-webkit-scrollbar-thumb:hover {
      background: #666;
    }

    /* Progress Bar */
    .progress-bar {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 0.5rem;
      z-index: 1600;
    }

    .progress-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #333;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .progress-dot.active {
      background: #00ffff;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }

    .tutorial-section h1,
    .tutorial-section h2, 
    .tutorial-section h3,
    .tutorial-section h4,
    .tutorial-section h5,
    .tutorial-section h6 {
      display: none !important;
    }

    /* Typography */
    p { line-height: 1.6; margin-bottom: 1rem; }
    
    .highlight {
      background: rgba(255, 255, 0, 0.2);
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
    }

    .tip {
      background: #2c3e50;
      border-left: 4px solid #3498db;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 5px 5px 0;
      display: inline-block;
      max-width: fit-content;
    }

    .trail-image, .blur-image {
      width: 100%;
      max-width: none;
      border-radius: 10px;
      margin-bottom: 1rem;
      z-index: 25;
      position: relative;
    }

    .github-download-btn {
      display: flex;
      align-items: center;
      gap: 0.8rem;
      background: linear-gradient(45deg, #24292e, #586069);
      border: none;
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.1rem;
      font-weight: bold;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      margin: 1.5rem 0;
      text-decoration: none;
      width: fit-content;
    }

    .github-download-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(36, 41, 46, 0.4);
      background: linear-gradient(45deg, #2f363d, #6a737d);
    }

    .github-logo {
      width: 24px;
      height: 24px;
      fill: currentColor;
    }

    .copy-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 255, 255, 0.9);
      color: #000;
      padding: 1rem 2rem;
      border-radius: 10px;
      font-weight: bold;
      z-index: 5000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .copy-notification.show {
      opacity: 1;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .tutorial-section {
        padding: 0.25rem 1rem 1rem 1rem;
        min-height: calc(100vh - 60px);
      }
      
      .tutorial-section.has-background-image {
        padding-bottom: 500px;
      }
      
      .hero-title {
        font-size: 2.5rem;
      }
      
      .hero-subtitle {
        font-size: 1.2rem;
      }

      .section-layout {
        flex-direction: column;
        gap: 1.5rem;
        margin-bottom: 1.5rem;
        margin-top: 0.125rem;
      }

      .section-left,
      .section-right {
        flex: 1;
        width: 100%;
        padding-top: 0;
      }

      .static-image-container {
        height: 250px;
      }

      .mobile-parameters {
        display: block;
        margin: 1.5rem 0;
        padding: 1rem;
      }

      .hotspot {
        display: none !important;
      }

      .tutorial-nav {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
      }

      .nav-btn {
        font-size: 0.8rem;
        padding: 0.4rem 0.8rem;
      }

      .tutorial-header {
        flex-direction: column;
        align-items: stretch;
        min-height: auto;
        gap: 1rem;
        padding: 1rem 1rem;
      }

      .tutorial-title {
        max-width: 100%;
        text-align: center;
        font-size: clamp(1rem, 5vw, 1.8rem);
        margin-right: 0;
        margin-bottom: 0;
        line-height: 1.2;
      }

      .tutorial-nav {
        justify-content: space-around;
        width: 100%;
        gap: 0.5rem;
      }

      .widget-container {
        height: auto;
        max-height: 30vh;
        min-height: 200px;
        margin: 0.5rem 0;
      }

      .widget-buttons {
        margin-right: 0.25rem;
      }

      .tsv-table th,
      .tsv-table td {
        font-size: 0.65rem;
        padding: 1px 3px;
        min-width: 30px;
        max-width: 40px;
      }

      .code-content {
        font-size: 0.65rem;
        padding: 0.5rem;
      }

      .widget-btn {
        width: 24px;
        height: 24px;
        font-size: 0.9rem;
      }

      .widget-btn-fullscreen::before {
        font-size: 11px;
      }

      .widget-btn-copy::before {
        font-size: 9px;
      }

      .widget-btn-github::before {
        font-size: 11px;
      }

      .widget-title {
        font-size: 0.8rem;
      }

      .section-left > *:last-child,
      .section-right > *:last-child,
      .section-full > *:last-child {
        margin-bottom: 2rem;
      }
    }

    @media (min-width: 769px) {
      .section-left {
        flex: 2 1 66.666%;
        max-width: 66.666%;
      }

      .section-right {
        flex: 1 1 33.333%;
        max-width: 33.333%;
      }

      .widget-container {
        width: 100%;
        max-width: 100%;
      }

      .content-widget {
        width: 100%;
        max-width: 100%;
      }
    }

    @media (max-width: 480px) {
      .tutorial-section {
        padding: 0.2rem 0.75rem 0.75rem 0.75rem;
      }
      
      .tutorial-section.has-background-image {
        padding-bottom: 450px;
      }
      
      .mobile-parameters {
        margin: 1rem 0;
        padding: 0.75rem;
      }
      
      .widget-container {
        margin: 0.25rem 0;
        min-height: 150px;
      }
    }

    .section-left,
    .section-right,
    .section-full {
      overflow: visible;
      word-wrap: break-word;
    }
  </style>
</head>
<body>
  <!-- Hero Section -->
  <div class="hero-section" id="heroSection">
    <canvas class="hypercube-canvas" id="hypercube-canvas"></canvas>
    <button class="nav-btn close-btn" onclick="window.history.back()" style="position: absolute; top: 2rem; right: 2rem; z-index: 100;">×</button>
    
    <!-- Hero Settings Toggle -->
    <div class="hero-settings-toggle" id="heroSettingsToggle">
      <svg viewBox="0 0 24 24">
        <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
      </svg>
    </div>

    <!-- Hero Controls Panel -->
    <div class="hero-controls-panel" id="heroControlsPanel">
      <h4>4D Projection Controls</h4>
      <div class="control-group">
        <label for="hero-fov-control">FOV:</label>
        <input type="number" id="hero-fov-control" value="7" step="1" min="2" max="120">
      </div>
      <div class="control-group">
        <label for="hero-perspective-control">4D Scale:</label>
        <input type="number" id="hero-perspective-control" value="2.3" step="0.1" min="0.1" max="10">
      </div>
      <div class="control-group">
        <label for="hero-cameraz-control">Camera Z:</label>
        <input type="number" id="hero-cameraz-control" value="10" step="1" min="-100" max="50">
      </div>
      
      <!-- Mobile Accelerometer Toggle -->
      <div class="control-group" id="accelerometerToggleGroup" style="display: none;">
        <label for="accelerometer-toggle">Accelerometer:</label>
        <input type="checkbox" id="accelerometer-toggle" style="width: auto; margin-left: 0.5rem;">
      </div>
      
      <div class="info-section">
        <h4>Controls Info</h4>
        <p id="controlsInfo">• Move mouse to rotate in 3D space<br>• Scroll to rotate through 4th dimension</p>
      </div>
    </div>
    
    <div class="hero-content">
      <h1 class="hero-title">TESSERACT</h1>
      <p class="hero-subtitle">TouchDesigner Tutorial using GLSL<br>click to start</p>
    </div>
  </div>

  <!-- Tutorial Container -->
  <div class="tutorial-container" id="tutorialContainer">
    <!-- Tutorial Header -->
    <div class="tutorial-header">
      <div class="tutorial-title" id="currentSectionTitle">TESSERACT Overview</div>
      <div class="tutorial-nav">
        <button class="nav-btn" onclick="goToHero()">Home</button>
        <button class="nav-btn" onclick="goToTutorialsPage()">Tutorials</button>
        <button class="nav-btn circular" onclick="goToPrevSection()">‹</button>
        <button class="nav-btn circular" onclick="goToNextSection()">›</button>
        <button class="nav-btn close-btn" onclick="closeTutorial()">×</button>
      </div>
    </div>

    <!-- Tutorial Content -->
    <div class="tutorial-content">
      <div class="tutorial-scroller" id="tutorialScroller">
        
        <!-- Section 1: TESSERACT Overview -->
        <div class="tutorial-section">
          <div class="section-layout">
            <div class="section-left">
              <h1>TESSERACT Overview</h1>
              <p>Welcome to this interactive tutorial on creating a 4D hypercube (tesseract) in TouchDesigner using GLSL shaders. This project demonstrates advanced techniques for 4D rotation, perspective projection, and real-time interaction.</p>
              
              <div class="tip">
                <strong>Pro Tip:</strong> Understanding 4D rotations requires thinking beyond our 3D intuition. We'll break this down step by step!
              </div>
              
              <h3>What We'll Cover:</h3>
              <ul style="margin-left: 2rem; line-height: 1.8;">
                <li><strong>CHOP Networks:</strong> Mouse input processing and rotation control</li>
                <li><strong>4D Mathematics:</strong> Rotation matrices and perspective projection</li>
                <li><strong>GLSL Shaders:</strong> Vertex transformation and SDF rendering</li>
                <li><strong>Interactive Controls:</strong> Real-time parameter manipulation</li>
              </ul>
            </div>
            
            <div class="section-right">
              <h3>Key Resources:</h3>
              <p>This tutorial references concepts from:</p>
              <ul style="margin-left: 2rem; line-height: 1.8;">
                <li><a href="https://en.wikipedia.org/wiki/Tesseract" target="_blank" style="color: #00ffff;">Tesseract mathematics</a></li>
                <li><a href="https://hollasch.github.io/ray4/Four-Space_Visualization_of_4D_Objects.html" target="_blank" style="color: #00ffff;">4D projection techniques</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Rotation_matrix#In_four_dimensions" target="_blank" style="color: #00ffff;">4D rotation matrices</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Rotation_matrix" target="_blank" style="color: #00ffff;">3D rotation matrices</a></li>
                <li><a href="https://iquilezles.org/articles/distfunctions2d/" target="_blank" style="color: #00ffff;">Inigo Quilez's SDF functions</a></li>
                <li><a href="https://docs.derivative.ca/GLSL_TOP" target="_blank" style="color: #00ffff;">Writing GLSL TOPs in TouchDesigner</a></li>
              </ul>
            </div>
          </div>
        </div>

        <!-- Section 2: The CHOP Network -->
        <div class="tutorial-section">
          <div class="section-layout">
            <div class="section-left">
              <h1>The CHOP Network</h1>
              <p>Our CHOP network processes mouse input to control the hypercube rotation. We can use any input device to control any axis or parameter - the flexibility of TouchDesigner shines here.</p>
              
              <h3>Input Sources:</h3>
              <p>We take mouse position from either <span class="highlight">mousein</span> or <span class="highlight">panel</span> CHOPs, and scroll increment from mousein to control our hypercube rotation.</p>
              
              <h3>Network Flow:</h3>
              <p>The network processes raw input → applies velocity calculations → converts to angular position → feeds rotation matrices.</p>
            </div>
            
            <div class="section-right">
              <h3>Input Device Flexibility</h3>
              <p>We didn't have to use the mouse as our input - we could have used any input devices like:</p>
              <ul style="margin-left: 1rem; line-height: 1.8;">
                <li><strong>Xbox Controller:</strong> Analog sticks for smooth rotation</li>
                <li><strong>USB Joystick:</strong> Traditional flight stick input</li>
                <li><strong>Kinect:</strong> Body tracking for gesture control</li>
                <li><strong>Leap Motion:</strong> Hand tracking and finger gestures</li>
                <li><strong>MIDI Device:</strong> Knobs and faders for precise control</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- Additional sections would continue here... -->
        <!-- For brevity, I'll include just a few more key sections -->

        <!-- Section 9: Input Data 2 -->
        <div class="tutorial-section">
          <div class="section-layout">
            <div class="section-left">
              <h1>Input Data 2: Saved Data from TSV</h1>
              <p>In TouchDesigner we can input saved data in loads of ways. Here I've used a TSV file saved from a previous project in 2021 and loaded with a <span class="highlight">table DAT</span>, but equally it could have been saved as a waveform and opened with the <span class="highlight">filein CHOP</span>, or as a texture where tx, ty, tz, tw are stored as RGBA.</p>

              <h3>Data Storage Options:</h3>
              <ul style="margin-left: 2rem; line-height: 1.8;">
                <li><strong>TSV/CSV files:</strong> Table DAT for structured data</li>
                <li><strong>Waveforms:</strong> Filein CHOP for time-based data</li>
                <li><strong>Textures:</strong> RGBA channels for 4D coordinates</li>
                <li><strong>GLSL sampling:</strong> Direct access from shaders</li>
              </ul>

              <p>You can also sample data in a GLSL TOP from DATs, CHOPs or TOPs. Each row in the DAT, sample in the CHOP, and pixel in TOP all store the same 4 channels of data over 33 samples.</p>

              <div class="tip">
                <strong>Important:</strong> Save as TSV so it will open as a table in TouchDesigner!
              </div>
            </div>
            
            <div class="section-right">
              <div class="widget-container">
                <div class="widget-buttons">
                  <button class="widget-btn widget-btn-fullscreen" onclick="showTSVFullscreen()" title="Fullscreen"></button>
                  <button class="widget-btn widget-btn-copy" onclick="copyTSVToClipboard()" title="Copy to Clipboard"></button>
                  <button class="widget-btn widget-btn-github" onclick="downloadTesseractResources()" title="Download from GitHub"></button>
                </div>
                <div class="content-widget">
                  <div class="widget-content" id="tsvContent">
                    <table class="tsv-table" id="tsvTable">
                      <thead>
                        <tr>
                          <!-- Headers will be loaded dynamically from TSV file -->
                        </tr>
                      </thead>
                      <tbody>
                        <!-- TSV data will be loaded here dynamically -->
                      </tbody>
                    </table>
                  </div>
                  <div class="widget-header">
                    <div class="widget-title">Euler Cycle TSV Data</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <!-- Static Image Container -->
    <div class="static-image-container">
      <div class="image-transition-container" id="staticImageContainer">
        <div id="hotspotContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
        </div>
      </div>
    </div>

    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>
  </div>

  <!-- Parameter Dialog -->
  <div class="parameter-dialog" id="parameterDialog">
    <h4 id="parameterTitle">Parameters</h4>
    <div id="parameterContent"></div>
    <button class="widget-btn" onclick="hideParameterDialog()" style="margin-top: 1rem;">Close</button>
  </div>

  <!-- Copy Notification -->
  <div class="copy-notification" id="copyNotification">Copied to clipboard!</div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // Tutorial State
    let currentSection = 0;
    let previousSection = 0;
    const totalSections = 15;
    let tutorialOpen = false;
    let cleanupTimeout = null;
    let stickyHotspots = new Set();

    // Hypercube variables
    let scene, camera, renderer, uniforms;
    let mousePos = { x: 0, y: 0 };
    let normalizedMouse = { x: 0, y: 0 };
    let velocity = { x: 0, y: 0 };
    let slowVelocity = { x: 0, y: 0 };
    let angles = { rx: 0, ry: 0, rw: 0 };
    let wheelVelocity = 0;
    const maxSlowVelocity = 0.25;

    // Mobile detection and accelerometer
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    let accelerometerSupported = false;
    let accelerometerEnabled = false;
    let accelerometerPermission = false;

    // Accelerometer data
    let deviceAcceleration = { x: 0, y: 0, z: 0 };
    let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let lastOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let calibrationOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let isCalibrated = false;

    // Touch handling for mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    let permissionRequested = false;

    // Section titles for header
    const sectionTitles = [
      "TESSERACT Tutorial",
      "TESSERACT Overview", 
      "The CHOP Network",
      "Input Data 1: Mouse UV Control",
      "Rangeling CHOPs 1: Mouse Velocity",
      "Rangeling CHOPs 2: Centering and Scaling", 
      "Rangeling CHOPs 3: Angular Velocity",
      "Rangeling CHOPs 4: Mouse Wheel",
      "Rangeling CHOPs 5: Merging and Null",
      "Input Data 2: Saved Data from TSV",
      "Rotation Vertex GLSL",
      "Perspective GLSL", 
      "2D Points to 2D Lines",
      "SDF Uneven Capsule",
      "Post Processing"
    ];

    // Load dynamic content
    function loadDynamicContent() {
      // TSV loader
      fetch('https://raw.githubusercontent.com/TrueFiasco/website/main/Tesseract%20Tutorial%20Pictures/code/euler%20cycle.tsv')
        .then(res => {
          if (!res.ok) throw new Error('Failed to load TSV');
          return res.text();
        })
        .then(tsv => {
          const rows = tsv.trim().split('\n');
          const headers = rows[0].split('\t');
          const dataRows = rows.slice(1);
          
          const thead = document.querySelector('#tsvTable thead tr');
          thead.innerHTML = '';
          headers.forEach(header => {
            const th = document.createElement('th');
            th.textContent = header.trim();
            thead.appendChild(th);
          });
          
          const tbody = document.querySelector('#tsvTable tbody');
          tbody.innerHTML = '';
          dataRows.forEach(row => {
            const cells = row.split('\t');
            const tr = document.createElement('tr');
            cells.forEach(cell => {
              const td = document.createElement('td');
              td.textContent = cell.trim();
              tr.appendChild(td);
            });
            tbody.appendChild(tr);
          });
        })
        .catch(err => {
          console.error('Failed to load TSV:', err);
          const tbody = document.querySelector('#tsvTable tbody');
          tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #ff6b6b; font-style: italic;">Failed to load TSV data</td></tr>';
        });
    }

    // Initialize hypercube
    async function initHypercube() {
      const canvas = document.getElementById('hypercube-canvas');
      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      
      renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      const vertexData = new Float32Array(33 * 4);
      const vertices = [
        [0,0,0,0], [0,0,0,1], [1,0,0,1], [1,1,0,1], [0,1,0,1], [0,0,0,1], [0,0,1,1], [0,1,1,1],
        [0,1,0,1], [0,1,0,0], [0,1,1,0], [0,1,1,1], [1,1,1,1], [1,1,1,0], [1,1,0,0], [1,1,0,1],
        [1,1,1,1], [1,0,1,1], [1,0,1,0], [1,0,0,0], [1,0,0,1], [1,0,1,1], [0,0,1,1], [0,0,1,0],
        [1,0,1,0], [1,1,1,0], [0,1,1,0], [0,0,1,0], [0,0,0,0], [1,0,0,0], [1,1,0,0], [0,1,0,0],
        [0,0,0,0]
      ];
      
      vertices.forEach((vertex, i) => {
        vertexData[i * 4] = (vertex[0] - 0.5) * 2;
        vertexData[i * 4 + 1] = (vertex[1] - 0.5) * 2;
        vertexData[i * 4 + 2] = (vertex[2] - 0.5) * 2;
        vertexData[i * 4 + 3] = (vertex[3] - 0.5) * 2;
      });
      
      const vertexTexture = new THREE.DataTexture(
        vertexData, 33, 1, THREE.RGBAFormat, THREE.FloatType
      );
      vertexTexture.needsUpdate = true;
      
      const textTexture = await createTesseractTextTexture();
      
      const fragmentShader = `
        uniform float u_time;
        uniform vec2 u_resolution;
        uniform sampler2D u_vertices;
        uniform sampler2D u_textTexture;
        uniform vec3 u_rotation;
        uniform float u_lineWidth;
        uniform float u_fov;
        uniform float u_perspective;
        uniform float u_cameraZ;
        
        mat4 rotateX(float angle) {
          float c = cos(angle); float s = sin(angle);
          return mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0);
        }
        
        mat4 rotateY(float angle) {
          float c = cos(angle); float s = sin(angle);
          return mat4(c, 0.0, s, 0.0, 0.0, 1.0, 0.0, 0.0, -s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0);
        }
        
        mat4 rotateWY(float angle) {
          float c = cos(angle); float s = sin(angle);
          return mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c);
        }
        
        float distanceToLineSegment(vec2 p, vec2 a, vec2 b) {
          vec2 pa = p - a; vec2 ba = b - a;
          float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
          return length(pa - ba * h);
        }
        
        vec2 project4DTo2D(vec4 point4D) {
          vec3 pos3D = point4D.xyz * (point4D.w + u_perspective);
          vec3 camPos = vec3(0.0, 0.0, u_cameraZ);
          vec3 relPos = pos3D - camPos;
          float f = 1.0 / tan(radians(u_fov) * 0.5);
          vec2 projected = vec2(f * relPos.x / relPos.z, f * relPos.y / relPos.z);
          return projected * 0.1;
        }
        
        void main() {
          vec2 st = gl_FragCoord.xy / u_resolution.xy;
          vec2 screenSt = st;
          st = (st - 0.5) * 2.0;
          st.x *= u_resolution.x / u_resolution.y;
          
          vec4 textSample = texture2D(u_textTexture, screenSt);
          float textMask = textSample.r;
          
          mat4 rotation = rotateWY(u_rotation.z) * rotateY(u_rotation.y) * rotateX(u_rotation.x);
          
          float minDist = 1000.0;
          
          for (int i = 0; i < 32; i++) {
            vec4 vertex1 = texture2D(u_vertices, vec2((float(i) + 0.5) / 33.0, 0.5));
            vec4 vertex2 = texture2D(u_vertices, vec2((float(i + 1) + 0.5) / 33.0, 0.5));
            
            vertex1 = rotation * vertex1;
            vertex2 = rotation * vertex2;
            
            vec2 p1 = project4DTo2D(vertex1);
            vec2 p2 = project4DTo2D(vertex2);
            
            float dist = distanceToLineSegment(st, p1, p2);
            minDist = min(minDist, dist);
          }
          
          float intensity = smoothstep(0.0, u_lineWidth, minDist);
          
          vec3 lineColor = vec3(0.2, 0.8, 1.0);
          vec3 glowColor = vec3(0.6, 0.3, 1.0);
          vec3 bgColor = vec3(0.05, 0.05, 0.15);
          
          vec3 color = mix(lineColor, bgColor, intensity);
          float glow = exp(-minDist * 30.0) * 0.5;
          color += glow * glowColor;
          
          if (textMask > 0.1) {
            float textGlow = exp(-minDist * 20.0) * 2.0;
            vec3 textGlowColor = vec3(1.0, 0.8, 0.2);
            color += textGlow * textGlowColor * textMask;
            
            if (minDist < u_lineWidth * 2.0) {
              vec3 textLineColor = vec3(1.0, 0.9, 0.3);
              float textInfluence = (1.0 - minDist / (u_lineWidth * 2.0)) * textMask;
              color = mix(color, textLineColor, textInfluence * 0.7);
            }
            
            float sparkleFreq = 15.0;
            float sparkle = sin(st.x * sparkleFreq + u_time * 3.0) * sin(st.y * sparkleFreq + u_time * 2.5);
            sparkle = pow(max(sparkle, 0.0), 3.0);
            color += sparkle * 0.3 * textMask * vec3(1.0, 0.8, 0.4);
          }
          
          float pulse = sin(u_time * 2.0) * 0.5 + 0.5;
          if (minDist < u_lineWidth * 0.5) {
            float pulseMult = textMask > 0.1 ? 0.6 : 0.3;
            color = mix(color, vec3(1.0), pulse * pulseMult);
          }
          
          float sparkle = sin(st.x * 20.0 + u_time) * sin(st.y * 20.0 + u_time * 1.1);
          color += sparkle * 0.05 * (1.0 - intensity) * (1.0 - textMask);
          
          gl_FragColor = vec4(color, 0.8);
        }
      `;

      const vertexShader = `void main() { gl_Position = vec4(position, 1.0); }`;

      uniforms = {
        u_time: { value: 0.0 },
        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        u_vertices: { value: vertexTexture },
        u_textTexture: { value: textTexture },
        u_rotation: { value: new THREE.Vector3(0, 0, 0) },
        u_lineWidth: { value: 0.02 },
        u_fov: { value: 7.0 },
        u_perspective: { value: 2.3 },
        u_cameraZ: { value: 10.0 }
      };

      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true
      });

      const plane = new THREE.PlaneGeometry(2, 2);
      const mesh = new THREE.Mesh(plane, material);
      scene.add(mesh);
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('wheel', onWheel);
      
      if (isMobile) {
        canvas.addEventListener('touchstart', onTouchStart);
        canvas.addEventListener('touchmove', onTouchMove);
        canvas.addEventListener('touchend', onTouchEnd);
      } else {
        canvas.addEventListener('click', openTutorial);
      }
      
      canvas.style.cursor = 'pointer';
    }

    // Create text texture for TESSERACT
    async function createTesseractTextTexture() {
      await waitForFonts();
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      const baseFontSize = Math.min(window.innerWidth * 0.12, 144);
      const subtitleFontSize = Math.min(window.innerWidth * 0.036, 36);
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      ctx.font = `${baseFontSize}px "Spy Agency"`;
      const titleY = centerY - 30;
      ctx.fillText('TESSERACT', centerX, titleY);
      
      ctx.font = `400 ${subtitleFontSize}px Orbitron`;
      const subtitleLine1 = 'TouchDesigner Tutorial using GLSL';
      const subtitleLine2 = 'click to start';
      const subtitleY = titleY + baseFontSize * 0.8 + 20;
      const lineSpacing = subtitleFontSize * 1.2;
      
      ctx.fillText(subtitleLine1, centerX, subtitleY);
      ctx.fillText(subtitleLine2, centerX, subtitleY + lineSpacing);
      
      return new THREE.CanvasTexture(canvas);
    }

    async function waitForFonts() {
      return new Promise((resolve) => {
        const testCanvas = document.createElement('canvas');
        const testCtx = testCanvas.getContext('2d');
        
        function checkFonts() {
          testCtx.font = '48px "Spy Agency", serif';
          const spyAgencyWidth = testCtx.measureText('TESSERACT').width;
          testCtx.font = '48px serif';
          const serifWidth = testCtx.measureText('TESSERACT').width;
          
          if (Math.abs(spyAgencyWidth - serifWidth) > 1) {
            resolve();
          } else {
            setTimeout(checkFonts, 100);
          }
        }
        checkFonts();
        setTimeout(resolve, 5000);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      
      uniforms.u_time.value += 0.016;
      
      uniforms.u_rotation.value.x = angles.rx;
      uniforms.u_rotation.value.y = angles.ry;
      uniforms.u_rotation.value.z = angles.rw;
      
      angles.rx += velocity.x + slowVelocity.x;
      angles.ry += velocity.y + slowVelocity.y;
      angles.rw += wheelVelocity;
      
      velocity.x *= 0.95;
      velocity.y *= 0.95;
      wheelVelocity *= 0.96;
      
      if (!accelerometerEnabled) {
        const targetSlowVelX = normalizedMouse.y * 0.0125;
        const targetSlowVelY = normalizedMouse.x * 0.0125;
        
        slowVelocity.x += (targetSlowVelX - slowVelocity.x) * 0.1;
        slowVelocity.y += (targetSlowVelY - slowVelocity.y) * 0.1;
      }
      
      const slowSpeed = Math.sqrt(slowVelocity.x * slowVelocity.x + slowVelocity.y * slowVelocity.y);
      if (slowSpeed > maxSlowVelocity) {
        slowVelocity.x = (slowVelocity.x / slowSpeed) * maxSlowVelocity;
        slowVelocity.y = (slowVelocity.y / slowSpeed) * maxSlowVelocity;
      }
      
      renderer.render(scene, camera);
    }

    // Mouse event handlers
    function onMouseMove(event) {
      if (tutorialOpen || (isMobile && accelerometerEnabled)) return;
      
      const newMousePos = {
        x: event.clientX / window.innerWidth,
        y: event.clientY / window.innerHeight
      };
      
      const deltaX = (newMousePos.x - mousePos.x) * 2.0;
      const deltaY = (newMousePos.y - mousePos.y) * 2.0;
      
      velocity.x += deltaY * 0.15;
      velocity.y += deltaX * 0.15;
      
      mousePos = newMousePos;
      
      normalizedMouse.x = (mousePos.x - 0.5) * 2;
      normalizedMouse.y = (mousePos.y - 0.5) * 2;
    }

    // Mobile touch handlers
    function onTouchStart(event) {
      event.preventDefault();
      const touch = event.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchStartTime = Date.now();
    }

    function onTouchMove(event) {
      event.preventDefault();
      if (!tutorialOpen && !accelerometerEnabled) {
        const touch = event.touches[0];
        const deltaX = (touch.clientX - touchStartX) / window.innerWidth;
        const deltaY = (touch.clientY - touchStartY) / window.innerHeight;
        
        velocity.x += deltaY * 0.1;
        velocity.y += deltaX * 0.1;
      }
    }

    function onTouchEnd(event) {
      event.preventDefault();
      
      const touch = event.changedTouches[0];
      const deltaX = touch.clientX - touchStartX;
      const deltaY = touch.clientY - touchStartY;
      const deltaTime = Date.now() - touchStartTime;
      
      const isQuickTap = deltaTime < 300 && Math.abs(deltaX) < 30 && Math.abs(deltaY) < 30;
      const isSwipe = deltaTime < 500 && Math.abs(deltaX) > 50 && Math.abs(deltaX) > Math.abs(deltaY);
      
      if (tutorialOpen) {
        if (isSwipe) {
          if (deltaX > 0) {
            goToPrevSection();
          } else {
            goToNextSection();
          }
        }
      } else {
        if (isQuickTap) {
          if (isMobile && accelerometerSupported && !permissionRequested) {
            requestiOSPermissionIfNeeded();
            permissionRequested = true;
            return;
          }
          
          openTutorial();
        }
      }
    }

    // Accelerometer handlers
    function onDeviceMotion(event) {
      if (!accelerometerEnabled) return;
      if (tutorialOpen) return;
      
      const accel = event.accelerationIncludingGravity;
      if (accel && isCalibrated) {
        const accelSensitivity = 0.0008;
        
        velocity.x += accel.y * accelSensitivity;
        velocity.y += accel.x * accelSensitivity;
      }
    }

    function onDeviceOrientation(event) {
      if (!accelerometerEnabled) return;
      
      const alpha = event.alpha || 0;
      const beta = event.beta || 0;
      const gamma = event.gamma || 0;
      
      deviceOrientation = { alpha, beta, gamma };
      
      if (!isCalibrated) {
        calibrationOrientation = { alpha, beta, gamma };
        lastOrientation = { alpha, beta, gamma };
        isCalibrated = true;
        console.log('Accelerometer calibrated to:', calibrationOrientation);
        return;
      }
      
      if (tutorialOpen) return;
      
      let deltaBeta = beta - calibrationOrientation.beta;
      let deltaGamma = gamma - calibrationOrientation.gamma;
      let deltaAlpha = alpha - lastOrientation.alpha;
      
      if (deltaAlpha > 180) deltaAlpha -= 360;
      if (deltaAlpha < -180) deltaAlpha += 360;
      
      const orientationSensitivity = 0.00005;
      
      const normalizedBeta = Math.max(-30, Math.min(30, deltaBeta)) / 30;
      const targetSlowVelX = normalizedBeta * orientationSensitivity;
      
      const normalizedGamma = Math.max(-30, Math.min(30, deltaGamma)) / 30;
      const targetSlowVelY = normalizedGamma * orientationSensitivity;
      
      wheelVelocity += deltaAlpha * 0.0005;
      
      lastOrientation = { alpha, beta, gamma };
      
      const forceBlend = 0.05;
      slowVelocity.x += (targetSlowVelX - slowVelocity.x) * forceBlend;
      slowVelocity.y += (targetSlowVelY - slowVelocity.y) * forceBlend;
    }

    // Accelerometer setup
    async function setupAccelerometer() {
      if (!isMobile) return;
      
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceOrientationEvent !== 'undefined') {
        accelerometerSupported = true;
        
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          accelerometerPermission = false;
        } else {
          accelerometerPermission = true;
          
          const toggleGroup = document.getElementById('accelerometerToggleGroup');
          if (toggleGroup) {
            toggleGroup.style.display = 'flex';
          }
          
          enableAccelerometer(true);
        }
        
        updateControlsInfo();
      }
    }

    async function requestiOSPermissionIfNeeded() {
      if (accelerometerSupported && !accelerometerPermission && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission === 'granted') {
            accelerometerPermission = true;
            
            const toggleGroup = document.getElementById('accelerometerToggleGroup');
            if (toggleGroup) {
              toggleGroup.style.display = 'flex';
            }
            
            enableAccelerometer(true);
            updateControlsInfo();
            
            console.log('iOS accelerometer permission granted');
          } else {
            console.log('iOS accelerometer permission denied');
          }
        } catch (error) {
          console.log('DeviceOrientation permission denied or failed:', error);
        }
      }
    }

    function enableAccelerometer(enable) {
      if (!accelerometerSupported || !accelerometerPermission) return;
      
      if (enable && !accelerometerEnabled) {
        isCalibrated = false;
        
        window.addEventListener('devicemotion', onDeviceMotion);
        window.addEventListener('deviceorientation', onDeviceOrientation);
        accelerometerEnabled = true;
        
        const toggle = document.getElementById('accelerometer-toggle');
        if (toggle) toggle.checked = true;
        
        console.log('Accelerometer enabled - will calibrate on first reading');
        
      } else if (!enable && accelerometerEnabled) {
        window.removeEventListener('devicemotion', onDeviceMotion);
        window.removeEventListener('deviceorientation', onDeviceOrientation);
        accelerometerEnabled = false;
        isCalibrated = false;
        
        const toggle = document.getElementById('accelerometer-toggle');
        if (toggle) toggle.checked = false;
        
        console.log('Accelerometer disabled');
      }
      
      updateControlsInfo();
    }

    function updateControlsInfo() {
      const controlsInfo = document.getElementById('controlsInfo');
      if (!controlsInfo) return;
      
      if (isMobile && accelerometerEnabled) {
        controlsInfo.innerHTML = '• Tilt device to rotate in 3D space<br>• Rotate device to control 4th dimension<br>• Tap to open tutorial';
      } else if (isMobile && accelerometerSupported && !permissionRequested) {
        controlsInfo.innerHTML = '• First tap: Enable motion controls<br>• Second tap: Open tutorial<br>• Swipe left/right to navigate';
      } else if (isMobile) {
        controlsInfo.innerHTML = '• Touch and drag to rotate<br>• Tap to open tutorial<br>• Swipe left/right to navigate';
      } else {
        controlsInfo.innerHTML = '• Move mouse to rotate in 3D space<br>• Scroll to rotate through 4th dimension';
      }
    }

    // Navigation functions
    function openTutorial() {
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }
      transitionToSection(1);
      initProgressBar();
    }

    function closeTutorial() {
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }
      transitionToSection(0);
    }

    function goToHero() {
      closeTutorial();
    }

    function goToTutorialsPage() {
      window.open('https://truefiasco.org/tutorials', '_blank');
    }

    function goToNextSection() {
      if (currentSection < 14) {
        transitionToSection(currentSection + 1);
      }
    }

    function goToPrevSection() {
      if (currentSection > 1) {
        transitionToSection(currentSection - 1);
      }
    }

    function transitionToSection(newSection) {
      if (newSection === currentSection) return;
      
      previousSection = currentSection;
      currentSection = newSection;
      
      updateSectionTitle();
      updateTutorial();
    }

    function updateSectionTitle() {
      const titleElement = document.getElementById('currentSectionTitle');
      if (titleElement && currentSection >= 0 && currentSection < sectionTitles.length) {
        titleElement.textContent = sectionTitles[currentSection];
      }
    }

    function updateTutorial() {
      const scroller = document.getElementById('tutorialScroller');
      const tutorialContainer = document.getElementById('tutorialContainer');
      const progressBar = document.getElementById('progressBar');
      
      if (currentSection === 0) {
        tutorialContainer.classList.remove('active');
        progressBar.style.display = 'none';
        tutorialOpen = false;
      } else {
        tutorialContainer.classList.add('active');
        progressBar.style.display = 'flex';
        tutorialOpen = true;
        const offset = (currentSection - 1) * -100;
        scroller.style.transform = `translateX(${offset}vw)`;
      }
      
      updateProgressBar();
    }

    function initProgressBar() {
      const progressBar = document.getElementById('progressBar');
      progressBar.innerHTML = '';
      
      for (let i = 1; i <= 14; i++) {
        const dot = document.createElement('div');
        dot.className = 'progress-dot';
        if (i === currentSection) dot.classList.add('active');
        dot.onclick = () => transitionToSection(i);
        progressBar.appendChild(dot);
      }
    }

    function updateProgressBar() {
      const dots = document.querySelectorAll('.progress-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', (index + 1) === currentSection);
      });
    }

    // TSV functions
    function showTSVFullscreen() {
      console.log('TSV fullscreen not implemented in simplified version');
    }

    function copyTSVToClipboard() {
      const table = document.getElementById('tsvTable');
      let tsvText = '';
      
      const headerCells = table.getElementsByTagName('thead')[0].getElementsByTagName('th');
      const headers = [];
      for (let header of headerCells) {
        headers.push(header.textContent);
      }
      tsvText += headers.join('\t') + '\n';
      
      const rows = table.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
      for (let row of rows) {
        const cells = row.getElementsByTagName('td');
        const rowData = [];
        for (let cell of cells) {
          rowData.push(cell.textContent);
        }
        tsvText += rowData.join('\t') + '\n';
      }
      
      navigator.clipboard.writeText(tsvText).then(() => {
        console.log('TSV data copied to clipboard');
        showCopyNotification();
      }).catch(err => {
        console.error('Failed to copy TSV data: ', err);
      });
    }

    function downloadTesseractResources() {
      window.open('https://github.com/TrueFiasco/TouchDesigner-Tesseract-Tutorial', '_blank');
    }

    function showCopyNotification() {
      const notification = document.getElementById('copyNotification');
      notification.classList.add('show');
      setTimeout(() => {
        notification.classList.remove('show');
      }, 2000);
    }

    // Hero settings panel
    function setupHeroControls() {
      const toggle = document.getElementById('heroSettingsToggle');
      const panel = document.getElementById('heroControlsPanel');
      
      toggle.addEventListener('click', (e) => {
        e.stopPropagation();
        if (panel.style.display === 'none' || panel.style.display === '') {
          panel.style.display = 'block';
        } else {
          panel.style.display = 'none';
        }
      });

      panel.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      document.getElementById('hero-fov-control').addEventListener('input', function(e) {
        if (uniforms) uniforms.u_fov.value = parseFloat(e.target.value);
      });

      document.getElementById('hero-perspective-control').addEventListener('input', function(e) {
        if (uniforms) uniforms.u_perspective.value = parseFloat(e.target.value);
      });

      document.getElementById('hero-cameraz-control').addEventListener('input', function(e) {
        if (uniforms) uniforms.u_cameraZ.value = parseFloat(e.target.value);
      });

      const accelerometerToggle = document.getElementById('accelerometer-toggle');
      if (accelerometerToggle) {
        accelerometerToggle.addEventListener('change', function(e) {
          enableAccelerometer(e.target.checked);
        });
      }

      document.addEventListener('click', (e) => {
        if (!toggle.contains(e.target) && !panel.contains(e.target)) {
          panel.style.display = 'none';
        }
      });
    }

    function onWheel(event) {
      const anyModalOpen = document.querySelector('.widget-fullscreen.active');
      
      if (anyModalOpen) {
        return;
      }

      if (tutorialOpen) {
        event.preventDefault();
        const delta = event.deltaY;
        
        if (delta > 0) {
          goToNextSection();
        } else {
          goToPrevSection();
        }
        return;
      }
      
      const wheelDelta = event.deltaY > 0 ? 0.5 : -0.5;
      wheelVelocity += wheelDelta * 0.07;
    }

    function onWindowResize() {
      if (camera && renderer && uniforms) {
        renderer.setSize(window.innerWidth, window.innerHeight);
        uniforms.u_resolution.value.x = window.innerWidth;
        uniforms.u_resolution.value.y = window.innerHeight;
      }
    }

    async function init() {
      await initHypercube();
      setupHeroControls();
      await setupAccelerometer();
      loadDynamicContent();
      animate();
      initProgressBar();
      updateSectionTitle();
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    window.addEventListener('resize', onWindowResize);

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        console.log('Escape key pressed');
      }
    });
  </script>
</body>
</html>
