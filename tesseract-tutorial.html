<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tesseract Tutorial - Interactive TouchDesigner Guide</title>
  <link rel="stylesheet" href="layoutTesseract.css" />
  <style>
    /* Enhanced mobile swipe feedback styles */
    .tutorial-section {
      transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .tutorial-section.swiping {
      transition: none;
    }
    
    .swipe-indicator {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0, 255, 255, 0.8);
      color: #000;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-weight: bold;
      z-index: 3000;
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
      font-size: 0.9rem;
    }
    
    .swipe-indicator.left {
      left: 2rem;
    }
    
    .swipe-indicator.right {
      right: 2rem;
    }
    
    .swipe-indicator.show {
      opacity: 1;
    }
    
    .swipe-indicator.boundary {
      background: rgba(255, 107, 107, 0.8);
      color: #fff;
    }
    
    /* Enhanced control panel styles matching index.html */
    .controls-panel {
      position: fixed;
      top: 2rem;
      left: 2rem;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.8);
      padding: 1.5rem;
      border-radius: 15px;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      font-size: 0.9rem;
      min-width: 280px;
      display: none;
      pointer-events: auto;
    }

    .controls-panel h4 {
      color: #4ecdc4;
      margin-bottom: 1rem;
      text-align: center;
    }

    .control-group {
      margin-bottom: 0.8rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .control-group label {
      color: #ffffff;
      font-size: 0.85rem;
      min-width: 100px;
    }

    .control-group input {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      color: white;
      padding: 0.3rem 0.5rem;
      font-size: 0.8rem;
      width: 80px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .control-group input:focus {
      outline: none;
      border-color: #4ecdc4;
      background: rgba(255, 255, 255, 0.15);
    }

    .button-group {
      margin-top: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .button-row {
      display: flex;
      gap: 0.5rem;
      justify-content: space-between;
    }

    .control-button {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      color: white;
      padding: 0.5rem 1rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      flex: 1;
      min-width: 0;
    }

    .control-button:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: #4ecdc4;
      transform: translateY(-1px);
    }

    .control-button:active {
      transform: translateY(0);
    }

    .control-button.disabled {
      background: rgba(255, 100, 100, 0.3);
      border-color: rgba(255, 100, 100, 0.5);
      color: rgba(255, 255, 255, 0.7);
    }

    .control-button.disabled:hover {
      background: rgba(255, 100, 100, 0.4);
      border-color: rgba(255, 100, 100, 0.7);
    }

    .control-button.wide {
      flex: 2;
    }
    
    /* Motion control override button styling */
    #motion-control-toggle {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      color: white;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
    
    #motion-control-toggle:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: #4ecdc4;
    }

    .mobile-only {
      display: none;
    }

    .desktop-only {
      display: block;
    }

    .settings-toggle {
      position: fixed;
      top: 2rem;
      left: 2rem;
      z-index: 1001;
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .settings-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.5);
      transform: rotate(90deg);
    }

    .settings-toggle svg {
      width: 24px;
      height: 24px;
      fill: #ffffff;
    }

    .info-section {
      margin-top: 1.5rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }

    .info-section h4 {
      color: #4ecdc4;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .info-section p {
      margin-bottom: 0.3rem;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.9);
    }

    /* Desktop click hint */
    .click-hint {
      position: absolute;
      bottom: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid rgba(0, 255, 255, 0.3);
      color: #00ffff;
      padding: 1rem 2rem;
      border-radius: 50px;
      font-size: 1.1rem;
      font-family: 'Orbitron', 'Arial', sans-serif;
      font-weight: 400;
      animation: pulse-hint 2s infinite ease-in-out;
      backdrop-filter: blur(10px);
      z-index: 50;
      pointer-events: none;
      display: none;
    }

    @keyframes pulse-hint {
      0%, 100% { 
        transform: translateX(-50%) scale(1);
        opacity: 0.7;
      }
      50% { 
        transform: translateX(-50%) scale(1.05);
        opacity: 1;
      }
    }

    .hero-section:hover .click-hint {
      display: block;
    }

    /* Mobile responsive adjustments */
    @media (max-width: 768px) {
      .mobile-only {
        display: block;
      }
      
      .desktop-only {
        display: none;
      }

      .controls-panel {
        min-width: 300px;
        max-width: calc(100vw - 4rem);
      }

      .button-row {
        flex-wrap: wrap;
      }

      .control-button {
        font-size: 0.75rem;
        padding: 0.4rem 0.8rem;
        min-width: 80px;
      }

      .control-group label {
        min-width: 80px;
        font-size: 0.8rem;
      }

      .click-hint {
        display: none !important;
      }
    }

    /* Motion control UI styles */
    .motion-control-panel {
      position: fixed;
      bottom: 2rem;
      left: 2rem;
      z-index: 200;
      background: rgba(0, 0, 0, 0.8);
      padding: 1rem;
      border-radius: 12px;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      font-size: 0.85rem;
      min-width: 200px;
      display: none;
      pointer-events: auto;
    }
    
    .motion-indicator {
      position: fixed;
      top: 2rem;
      right: 70px;
      z-index: 150;
      width: 40px;
      height: 40px;
      background: rgba(0, 255, 127, 0.2);
      border: 2px solid rgba(0, 255, 127, 0.6);
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: all 0.3s ease;
      pointer-events: auto;
      cursor: pointer;
    }
    
    .motion-indicator.active {
      background: rgba(0, 255, 127, 0.4);
      border-color: rgba(0, 255, 127, 0.9);
      box-shadow: 0 0 15px rgba(0, 255, 127, 0.4);
      animation: subtle-pulse 2s infinite ease-in-out;
    }
    
    @keyframes subtle-pulse {
      0%, 100% { box-shadow: 0 0 15px rgba(0, 255, 127, 0.4); }
      50% { box-shadow: 0 0 25px rgba(0, 255, 127, 0.6); }
    }
    
    .motion-indicator.calibrating {
      background: rgba(255, 165, 0, 0.4);
      border-color: rgba(255, 165, 0, 0.9);
      animation: pulse-orange 1s infinite;
    }
    
    @keyframes pulse-orange {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    .motion-permission-prompt {
      position: fixed;
      bottom: 6rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3000;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.5);
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      pointer-events: auto;
      max-width: 280px;
    }
    
    .motion-permission-prompt.show {
      opacity: 1;
      visibility: visible;
    }
    
    .motion-permission-prompt h4 {
      color: #00ffff;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }
    
    .motion-permission-prompt p {
      font-size: 0.8rem;
      margin-bottom: 1rem;
      line-height: 1.3;
    }
    
    .motion-permission-buttons {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
    }
    
    .motion-btn {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid rgba(0, 255, 255, 0.5);
      color: #00ffff;
      padding: 0.4rem 0.8rem;
      border-radius: 5px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .motion-btn:hover {
      background: rgba(0, 255, 255, 0.3);
      border-color: rgba(0, 255, 255, 0.8);
    }
    
    .motion-btn.decline {
      background: rgba(255, 107, 107, 0.2);
      border-color: rgba(255, 107, 107, 0.5);
      color: #ff6b6b;
    }
    
    .motion-btn.decline:hover {
      background: rgba(255, 107, 107, 0.3);
      border-color: rgba(255, 107, 107, 0.8);
    }
  </style>
</head>
<body>
  <!-- Hero Section -->
  <div class="hero-section" id="heroSection">
    <canvas class="hypercube-canvas" id="hypercube-canvas"></canvas>
    
    <!-- Desktop Click Hint -->
    <div class="click-hint">Click anywhere to start tutorial</div>
    
    <!-- Back Button -->
    <button class="nav-btn close-btn" onclick="window.history.back()" style="position: absolute; top: 2rem; right: 2rem; z-index: 100;">√ó</button>
    
    <!-- Settings Toggle -->
    <div class="settings-toggle" id="settings-toggle">
      <svg viewBox="0 0 24 24">
        <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
      </svg>
    </div>

    <!-- Enhanced Controls Panel -->
    <div class="controls-panel" id="controls-panel">
      <h4>4D Projection Controls</h4>
      
      <!-- Parameter Controls with Filtering -->
      <div class="control-group">
        <label for="fov-control">FOV:</label>
        <input type="number" id="fov-control" value="7" step="1" min="2" max="120">
      </div>
      <div class="control-group">
        <label for="perspective-control">4D Scale:</label>
        <input type="number" id="perspective-control" value="2.3" step="0.1" min="0.1" max="10">
      </div>
      <div class="control-group">
        <label for="cameraz-control">Camera Z:</label>
        <input type="number" id="cameraz-control" value="10" step="1" min="-100" max="50">
      </div>
      
      <!-- Filter Strength Control -->
      <div class="control-group">
        <label for="filter-strength">Filter:</label>
        <input type="range" id="filter-strength" value="0.1" min="0.01" max="1" step="0.01" style="width: 80px;" title="Parameter change smoothing">
      </div>
      
      <!-- Motion Control Override (for users who previously declined) -->
      <div class="control-group mobile-only" id="motion-control-group">
        <label for="motion-control-toggle">Motion Control:</label>
        <button class="control-button" id="motion-control-toggle" style="width: 80px; padding: 0.2rem 0.5rem; font-size: 0.75rem;">Enable</button>
      </div>
      
      <div class="button-group">
        <!-- Reset Button -->
        <button class="control-button wide" id="reset-rotation">Reset Rotation</button>
        
        <!-- Desktop Rotation Controls (3 axis) -->
        <div class="desktop-only">
          <div class="button-row">
            <button class="control-button" id="stop-rx">Stop RX</button>
            <button class="control-button" id="stop-ry">Stop RY</button>
            <button class="control-button" id="stop-rw">Stop RW</button>
          </div>
        </div>
        
        <!-- Mobile Enhanced Controls -->
        <div class="mobile-only">
          <div class="button-row">
            <button class="control-button" id="stop-rx-mobile">Stop RX</button>
            <button class="control-button" id="stop-ry-mobile">Stop RY</button>
            <button class="control-button" id="stop-rw-mobile">Stop RW</button>
          </div>
          <div class="button-row">
            <button class="control-button" id="stop-motion">Stop Motion</button>
            <button class="control-button" id="stop-touch">Stop Touch</button>
            <button class="control-button" id="invert-x">Fix X-Axis</button>
          </div>
        </div>
      </div>
      
      <div class="info-section">
        <h4>4D Hypercube Controls</h4>
        <p class="desktop-only">‚Ä¢ Click anywhere to start tutorial</p>
        <p class="desktop-only">‚Ä¢ Move mouse to rotate in 3D space</p>
        <p class="desktop-only">‚Ä¢ Scroll to rotate through 4th dimension</p>
        <p class="mobile-only">‚Ä¢ Tap button below to start tutorial</p>
        <p class="mobile-only">‚Ä¢ Tilt device to rotate hypercube</p>
        <p class="mobile-only">‚Ä¢ Touch and drag for manual control</p>
        <p class="mobile-only">‚Ä¢ Use "Motion Control" above to enable device tilt</p>
      </div>
    </div>
    
    <div class="hero-content">
      <!-- Hidden HTML titles - only shader text will be visible -->
      <h1 class="hero-title" style="opacity: 0; pointer-events: none; position: absolute; visibility: hidden;">TESSERACT</h1>
      <p class="hero-subtitle" style="opacity: 0; pointer-events: none; position: absolute; visibility: hidden;">TouchDesigner Tutorial using GLSL<br>Interactive 4D Hypercube Visualization</p>
    </div>
  </div>
  
  <!-- Mobile-only tutorial button -->
  <div class="mobile-tutorial-button" id="mobileTutorialBtn" style="z-index: 1000;">
    <button class="mobile-start-btn" id="mobileStartBtn">
      Start Tutorial
    </button>
  </div>
  
  <!-- Swipe Indicators -->
  <div class="swipe-indicator left" id="swipeIndicatorLeft">‚Üê Previous</div>
  <div class="swipe-indicator right" id="swipeIndicatorRight">Next ‚Üí</div>
  
  <!-- Motion Control UI -->
  <div class="motion-indicator" id="motionIndicator" title="Motion Control">üì±</div>
  
  <div class="motion-permission-prompt" id="motionPermissionPrompt">
    <h4>Enhanced Experience</h4>
    <p>Enable motion control to rotate the hypercube by tilting your device</p>
    <div class="motion-permission-buttons">
      <button class="motion-btn" id="enableMotionBtn">Enable</button>
      <button class="motion-btn decline" id="declineMotionBtn">No thanks</button>
    </div>
  </div>
  
  <!-- Tutorial Container Placeholder - will be loaded dynamically -->
  <div id="tutorialContainer"></div>
  
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Your existing Tesseract Shader Module -->
  <script src="shaderTesseract.js"></script>

  <script>
    // ==========================================
    // CONTROL PANEL BUTTON EXPLANATIONS
    // ==========================================
    
    /*
    BUTTON EFFECTS EXPLAINED:
    
    üîÑ RESET ROTATION: 
    - Immediately snaps the hypercube back to center/neutral position
    - Clears all rotation angles (rx=0, ry=0, rw=0)
    - Shows green "Reset ‚úì" feedback
    
    üõë STOP RX/RY/RW (Desktop): 
    - RX = X-axis rotation (mouse up/down movement)
    - RY = Y-axis rotation (mouse left/right movement)  
    - RW = 4D-axis rotation (mouse wheel/scroll)
    - Toggles between "Stop" and "Enable" for each axis
    - When STOPPED: that axis won't rotate anymore
    - When ENABLED: that axis responds to input again
    
    üì± MOBILE CONTROLS:
    - Stop Motion = Disable/enable device tilt rotation
    - Stop Touch = Disable/enable touch drag rotation
    - Fix X-Axis = Invert X rotation direction for mobile devices
    
    üéõÔ∏è FILTER SLIDER:
    - Controls how smoothly parameter changes are applied
    - 0.01 = Very smooth/slow changes
    - 1.0 = Instant changes
    - Affects FOV, 4D Scale, and Camera Z adjustments
    
    üîí MOTION CONTROL PERSISTENCE:
    - Consent stored in localStorage permanently
    - Once granted, auto-enables on page refresh
    - Works across different pages on same domain
    - No repeated permission prompts
    
    üîÑ MOTION CONTROL OVERRIDE:
    - If user previously declined, they can re-enable via settings panel
    - "Motion Control: Enable" button appears in mobile settings
    - Button shows current state: Enable/Active/Paused
    - Allows users to change their mind without page refresh
    - Re-requests permission and updates stored consent
    */
    
    // ==========================================
    // Tutorial Section Configuration
    const sectionConfig = {
      1: { 
        aspectRatio: "3615:1097", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/network_overview.png",
        hotspots: []
      },
      2: { 
        aspectRatio: "1852:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/chop_network.png",
        hotspots: []
      },
      3: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/mouse_uv_control.png",
        hotspots: [
          { top: "35%", left: "17%", type: "select1-detailed" }
        ]
      },
      4: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/mouse_velocity.png",
        hotspots: [
          { top: "4%", left: "29%", type: "math3-params" },
          { top: "4%", left: "52%", type: "filter1-params" }
        ]
      },
      5: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/centering_and_scaling.png",
        hotspots: [
          { top: "35%", left: "29%", type: "math1-params" },
          { top: "35%", left: "41%", type: "speed2-params" }
        ]
      },
      6: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/angular_velocity.png",
        hotspots: [
          { top: "30%", left: "65%", type: "math2-params" },
          { top: "28%", left: "76%", type: "speed3-params" }
        ]
      },
      7: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/mouse_wheel.png",
        hotspots: [
          { top: "67%", left: "3%", type: "mousein1-wheel" },
          { top: "67%", left: "15%", type: "select2-params" },
          { top: "67%", left: "29%", type: "filter4-params" },
          { top: "67%", left: "41%", type: "filter3-params" },
          { top: "67%", left: "53%", type: "filter2-params" }
        ]
      },
      8: { 
        aspectRatio: "1852:571", 
        offset: {x: 0.1, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/merging_and_null.png",
        hotspots: []
      },
      9: { 
        aspectRatio: "1456:478", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/euler_in.png",
        hotspots: []
      },
      10: { 
        aspectRatio: "1920:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/rotate_vertex_glsl.png",
        hotspots: [
          { top: "35%", left: "40%", type: "vert_rotation" }
        ]
      },
      11: { 
        aspectRatio: "1920:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/prespective_glsl.png",
        hotspots: [
          { top: "40%", left: "50%", type: "vert_perspective" }
        ]
      },
      12: { 
        aspectRatio: "1920:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/2d_points_to_2d_lines.png",
        hotspots: [
          { top: "45%", left: "35%", type: "transform1" },
          { top: "45%", left: "65%", type: "reorder1" }
        ]
      },
      13: { 
        aspectRatio: "1920:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/sdf_uneven_capsule.png",
        hotspots: [
          { top: "50%", left: "50%", type: "line_mindist" }
        ]
      },
      14: { 
        aspectRatio: "1920:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/post_processing.png",
        hotspots: []
      }
    };

    // Section titles for header
    const sectionTitles = [
      "TESSERACT Tutorial",
      "TESSERACT Overview", 
      "The CHOP Network",
      "Input Data 1: Mouse UV Control",
      "Rangeling CHOPs 1: Mouse Velocity",
      "Rangeling CHOPs 2: Centering and Scaling", 
      "Rangeling CHOPs 3: Angular Velocity",
      "Rangeling CHOPs 4: Mouse Wheel",
      "Rangeling CHOPs 5: Merging and Null",
      "Input Data 2: Saved Data from TSV",
      "Rotation Vertex GLSL",
      "Perspective GLSL", 
      "2D Points to 2D Lines",
      "SDF Uneven Capsule",
      "Post Processing"
    ];

    // Tutorial State
    let currentSection = 0;
    let tutorialOpen = false;
    let cleanupTimeout = null;
    let stickyHotspots = new Set();

    // Mobile detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Enhanced Control Panel Class
    class EnhancedControlPanel {
      constructor(tesseractShader) {
        this.shader = tesseractShader;
        this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Filter state for parameter smoothing
        this.filterState = {
          fov: { current: 7.0, target: 7.0, strength: 0.1 },
          perspective: { current: 2.3, target: 2.3, strength: 0.1 },
          cameraZ: { current: 10.0, target: 10.0, strength: 0.1 }
        };
        
        // Enhanced rotation state
        this.rotationEnabled = {
          rx: true, ry: true, rw: true,
          motion: true, touch: true, invertX: false
        };
        
        this.init();
      }
      
      init() {
        this.setupToggle();
        this.setupParameterControls();
        this.setupRotationControls();
        this.setupMobileControls();
        this.startFilterLoop();
        
        // Initialize motion control button state after brief delay
        if (this.isMobile) {
          setTimeout(() => this.updateMotionControlButton(), 500);
        }
      }
      
      setupToggle() {
        document.getElementById('settings-toggle').addEventListener('click', () => {
          const panel = document.getElementById('controls-panel');
          if (panel.style.display === 'none' || panel.style.display === '') {
            panel.style.display = 'block';
          } else {
            panel.style.display = 'none';
          }
        });
      }
      
      setupParameterControls() {
        // FOV Control with filtering
        document.getElementById('fov-control').addEventListener('input', (e) => {
          this.filterState.fov.target = parseFloat(e.target.value);
        });
        
        // Perspective Control with filtering
        document.getElementById('perspective-control').addEventListener('input', (e) => {
          this.filterState.perspective.target = parseFloat(e.target.value);
        });
        
        // Camera Z Control with filtering
        document.getElementById('cameraz-control').addEventListener('input', (e) => {
          this.filterState.cameraZ.target = parseFloat(e.target.value);
        });
        
        // Filter Strength Control
        document.getElementById('filter-strength').addEventListener('input', (e) => {
          const strength = parseFloat(e.target.value);
          Object.keys(this.filterState).forEach(param => {
            this.filterState[param].strength = strength;
          });
        });
        
        // Motion Control Override Toggle (allows re-enabling after decline)
        this.setupMotionControlOverride();
      }
      
      setupMotionControlOverride() {
        const motionToggle = document.getElementById('motion-control-toggle');
        const motionGroup = document.getElementById('motion-control-group');
        
        if (!motionToggle || !this.isMobile) return;
        
        // Check if motion control is available
        const hasDeviceOrientation = 'DeviceOrientationEvent' in window;
        if (!hasDeviceOrientation) {
          motionGroup.style.display = 'none';
          return;
        }
        
        // Update button state based on current motion control status
        this.updateMotionControlButton();
        
        motionToggle.addEventListener('click', () => {
          const storedConsent = localStorage.getItem('motionControlConsent');
          
          if (storedConsent === 'granted') {
            // Toggle motion control on/off
            if (window.mobileMotionControl) {
              window.mobileMotionControl.toggleMotionControl();
              setTimeout(() => this.updateMotionControlButton(), 100);
            }
          } else {
            // Re-request permission (even if previously declined)
            this.requestMotionPermission();
          }
        });
      }
      
      updateMotionControlButton() {
        const motionToggle = document.getElementById('motion-control-toggle');
        if (!motionToggle) return;
        
        const storedConsent = localStorage.getItem('motionControlConsent');
        const isActive = window.mobileMotionControl?.isActive;
        
        if (storedConsent === 'granted') {
          if (isActive) {
            motionToggle.textContent = 'Active';
            motionToggle.style.background = 'rgba(0, 255, 0, 0.3)';
            motionToggle.style.borderColor = 'rgba(0, 255, 0, 0.5)';
            motionToggle.title = 'Motion control is active - click to pause';
          } else {
            motionToggle.textContent = 'Paused';
            motionToggle.style.background = 'rgba(255, 165, 0, 0.3)';
            motionToggle.style.borderColor = 'rgba(255, 165, 0, 0.5)';
            motionToggle.title = 'Motion control is paused - click to resume';
          }
        } else {
          motionToggle.textContent = 'Enable';
          motionToggle.style.background = '';
          motionToggle.style.borderColor = '';
          motionToggle.title = 'Click to enable device motion control';
        }
      }
      
      async requestMotionPermission() {
        console.log('üîÑ User clicked Motion Control override - re-requesting permission');
        console.log('üîÑ This allows users to enable motion control even after initially declining');
        
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          try {
            const response = await DeviceOrientationEvent.requestPermission();
            
            if (response === 'granted') {
              console.log('‚úÖ Motion permission granted via settings panel');
              console.log('üíæ Updating stored consent to "granted"');
              localStorage.setItem('motionControlConsent', 'granted');
              
              // Initialize motion control if not already done
              if (window.mobileMotionControl) {
                window.mobileMotionControl.isPermissionGranted = true;
                window.mobileMotionControl.startMotionDetection();
                window.mobileMotionControl.autoEnableMotionControl();
              }
              
              this.updateMotionControlButton();
              console.log('üéØ Motion control now active via settings override');
            } else {
              console.log('‚ùå Motion permission denied again via settings panel');
              localStorage.setItem('motionControlConsent', 'denied');
              this.updateMotionControlButton();
            }
          } catch (error) {
            console.error('Motion permission request failed:', error);
          }
        } else {
          // Android or older iOS - no permission needed
          console.log('üì± Android/older iOS - enabling motion control directly via settings');
          localStorage.setItem('motionControlConsent', 'granted');
          
          if (window.mobileMotionControl) {
            window.mobileMotionControl.isPermissionGranted = true;
            window.mobileMotionControl.startMotionDetection();
            window.mobileMotionControl.autoEnableMotionControl();
          }
          
          this.updateMotionControlButton();
          console.log('üéØ Motion control enabled via settings panel');
        }
      }
      }
      
      setupRotationControls() {
        // Reset Rotation - with visual feedback
        document.getElementById('reset-rotation').addEventListener('click', () => {
          if (this.shader && typeof this.shader.resetRotation === 'function') {
            this.shader.resetRotation();
            console.log('üîÑ Rotation reset to center position');
            
            // Visual feedback
            const button = document.getElementById('reset-rotation');
            const originalText = button.textContent;
            button.textContent = 'Reset ‚úì';
            button.style.background = 'rgba(0, 255, 0, 0.3)';
            setTimeout(() => {
              button.textContent = originalText;
              button.style.background = '';
            }, 1000);
          }
        });
        
        // Desktop Controls (3 axis) - using existing shader API with better feedback
        ['rx', 'ry', 'rw'].forEach(axis => {
          const button = document.getElementById(`stop-${axis}`);
          if (button) {
            button.addEventListener('click', () => {
              if (this.shader && typeof this.shader.toggleVelocity === 'function') {
                const enabled = this.shader.toggleVelocity(axis);
                this.updateButtonState(button, enabled, axis.toUpperCase());
                
                // Console feedback to show what's happening
                const axisNames = { rx: 'X-axis', ry: 'Y-axis', rw: '4D-axis' };
                console.log(`üéÆ ${axisNames[axis]} rotation ${enabled ? 'ENABLED' : 'STOPPED'}`);
              }
            });
          }
        });
      }
      
      setupMobileControls() {
        if (!this.isMobile) return;
        
        // Mobile RX, RY, RW controls with better feedback
        ['rx-mobile', 'ry-mobile', 'rw-mobile'].forEach(axisId => {
          const button = document.getElementById(`stop-${axisId}`);
          if (button) {
            button.addEventListener('click', () => {
              const axis = axisId.replace('-mobile', '');
              if (this.shader && typeof this.shader.toggleVelocity === 'function') {
                const enabled = this.shader.toggleVelocity(axis);
                this.updateButtonState(button, enabled, axis.toUpperCase());
                
                // Console feedback
                const axisNames = { rx: 'X-axis', ry: 'Y-axis', rw: '4D-axis' };
                console.log(`üì± ${axisNames[axis]} rotation ${enabled ? 'ENABLED' : 'STOPPED'}`);
              }
            });
          }
        });
        
        // Motion Control Toggle with clear feedback
        const motionButton = document.getElementById('stop-motion');
        if (motionButton) {
          motionButton.addEventListener('click', () => {
            this.rotationEnabled.motion = !this.rotationEnabled.motion;
            
            if (this.shader) {
              if (this.rotationEnabled.motion) {
                if (typeof this.shader.enableMotionControl === 'function') {
                  this.shader.enableMotionControl();
                  console.log('üì± Device motion control ENABLED');
                }
              } else {
                if (typeof this.shader.disableMotionControl === 'function') {
                  this.shader.disableMotionControl();
                  console.log('üì± Device motion control STOPPED');
                }
              }
            }
            
            this.updateButtonState(motionButton, this.rotationEnabled.motion, 'Motion');
          });
        }
        
        // Touch Control Toggle with feedback
        const touchButton = document.getElementById('stop-touch');
        if (touchButton) {
          touchButton.addEventListener('click', () => {
            this.rotationEnabled.touch = !this.rotationEnabled.touch;
            this.updateButtonState(touchButton, this.rotationEnabled.touch, 'Touch');
            
            console.log(`üì± Touch control ${this.rotationEnabled.touch ? 'ENABLED' : 'STOPPED'}`);
          });
        }
        
        // X-Axis Inversion Fix with clear feedback
        const invertButton = document.getElementById('invert-x');
        if (invertButton) {
          invertButton.addEventListener('click', () => {
            this.rotationEnabled.invertX = !this.rotationEnabled.invertX;
            
            if (this.rotationEnabled.invertX) {
              invertButton.textContent = 'X-Axis Fixed ‚úì';
              invertButton.classList.add('disabled');
              console.log('üì± X-axis rotation INVERTED (fixed for mobile)');
            } else {
              invertButton.textContent = 'Fix X-Axis';
              invertButton.classList.remove('disabled');
              console.log('üì± X-axis rotation NORMAL');
            }
          });
        }
      }
      
      updateButtonState(button, enabled, axisName) {
        if (enabled) {
          button.textContent = `Stop ${axisName}`;
          button.classList.remove('disabled');
        } else {
          button.textContent = `Enable ${axisName}`;
          button.classList.add('disabled');
        }
      }
      
      startFilterLoop() {
        const updateFilters = () => {
          let paramsChanged = false;
          
          // Apply filtering to each parameter
          Object.keys(this.filterState).forEach(param => {
            const state = this.filterState[param];
            const diff = state.target - state.current;
            
            if (Math.abs(diff) > 0.01) {
              state.current += diff * state.strength;
              paramsChanged = true;
            }
          });
          
          // Update shader parameters if they changed
          if (paramsChanged && this.shader && typeof this.shader.setShaderParams === 'function') {
            this.shader.setShaderParams({
              fov: this.filterState.fov.current,
              perspective: this.filterState.perspective.current,
              cameraZ: this.filterState.cameraZ.current
            });
          }
          
          requestAnimationFrame(updateFilters);
        };
        
        updateFilters();
      }
    }

    // ==========================================
    // MOBILE SWIPE GESTURE SYSTEM
    // ==========================================
    
    class MobileSwipeGestures {
      constructor() {
        this.isActive = false;
        this.touchData = {
          startX: 0,
          startY: 0,
          startTime: 0,
          currentX: 0,
          currentY: 0,
          isTracking: false
        };
        
        this.config = {
          minDistance: 50,
          maxVerticalDrift: 30,
          minVelocity: 0.3,
          minDuration: 50,
          maxDuration: 800,
          debounceTime: 300
        };
        
        this.lastSwipeTime = 0;
        this.isTransitioning = false;
        
        this.init();
      }
      
      init() {
        if (!isMobile) return;
        
        console.log('üéØ Initializing mobile swipe gestures');
        
        document.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
        document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
      }
      
      shouldIgnoreTouch(touch) {
        if (!tutorialOpen || currentSection < 1 || currentSection > 14) {
          return true;
        }
        
        if (document.querySelector('.widget-fullscreen.active')) {
          return true;
        }
        
        if (document.querySelector('.parameter-dialog.active')) {
          return true;
        }
        
        const buttonAreas = [
          '.tutorial-nav',
          '.progress-bar',
          '.nav-btn',
          '.widget-btn',
          '.close-btn',
          '.settings-toggle',
          '.controls-panel'
        ];
        
        for (const selector of buttonAreas) {
          const element = document.elementFromPoint(touch.clientX, touch.clientY);
          if (element && element.closest(selector)) {
            return true;
          }
        }
        
        return false;
      }
      
      handleTouchStart(event) {
        const touch = event.touches[0];
        
        if (this.shouldIgnoreTouch(touch)) {
          return;
        }
        
        this.touchData = {
          startX: touch.clientX,
          startY: touch.clientY,
          startTime: Date.now(),
          currentX: touch.clientX,
          currentY: touch.clientY,
          isTracking: true
        };
        
        console.log('üì± Swipe tracking started');
      }
      
      handleTouchMove(event) {
        if (!this.touchData.isTracking) return;
        
        const touch = event.touches[0];
        this.touchData.currentX = touch.clientX;
        this.touchData.currentY = touch.clientY;
        
        const deltaX = this.touchData.currentX - this.touchData.startX;
        const deltaY = this.touchData.currentY - this.touchData.startY;
        const absDeltaX = Math.abs(deltaX);
        const absDeltaY = Math.abs(deltaY);
        
        if (absDeltaX > 30 && absDeltaX > absDeltaY * 2 && absDeltaY < this.config.maxVerticalDrift) {
          event.preventDefault();
          
          if (absDeltaX > 20) {
            this.showSwipePreview(deltaX);
          }
        }
      }
      
      handleTouchEnd(event) {
        if (!this.touchData.isTracking) return;
        
        const touch = event.changedTouches[0];
        const endTime = Date.now();
        const duration = endTime - this.touchData.startTime;
        
        const deltaX = touch.clientX - this.touchData.startX;
        const deltaY = Math.abs(touch.clientY - this.touchData.startY);
        const distance = Math.abs(deltaX);
        const velocity = distance / duration;
        
        this.hideSwipePreview();
        
        const isValidGesture = this.validateGesture(deltaX, deltaY, distance, velocity, duration);
        
        if (isValidGesture) {
          this.processSwipe(deltaX);
        }
        
        this.touchData.isTracking = false;
        
        console.log(`üì± Swipe ended: deltaX=${deltaX}, deltaY=${deltaY}, velocity=${velocity.toFixed(2)}, valid=${isValidGesture}`);
      }
      
      validateGesture(deltaX, deltaY, distance, velocity, duration) {
        if (Date.now() - this.lastSwipeTime < this.config.debounceTime) {
          console.log('‚ùå Swipe ignored: too soon after last swipe');
          return false;
        }
        
        if (this.isTransitioning) {
          console.log('‚ùå Swipe ignored: transition in progress');
          return false;
        }
        
        if (distance < this.config.minDistance) {
          console.log(`‚ùå Swipe ignored: distance ${distance} < ${this.config.minDistance}`);
          return false;
        }
        
        if (deltaY > this.config.maxVerticalDrift) {
          console.log(`‚ùå Swipe ignored: vertical drift ${deltaY} > ${this.config.maxVerticalDrift}`);
          return false;
        }
        
        if (velocity < this.config.minVelocity) {
          console.log(`‚ùå Swipe ignored: velocity ${velocity.toFixed(2)} < ${this.config.minVelocity}`);
          return false;
        }
        
        if (duration < this.config.minDuration || duration > this.config.maxDuration) {
          console.log(`‚ùå Swipe ignored: duration ${duration} outside bounds [${this.config.minDuration}, ${this.config.maxDuration}]`);
          return false;
        }
        
        return true;
      }
      
      processSwipe(deltaX) {
        const direction = deltaX > 0 ? 'right' : 'left';
        let targetSection;
        let canSwipe = false;
        
        if (direction === 'right') {
          targetSection = currentSection - 1;
          canSwipe = currentSection > 1;
        } else {
          targetSection = currentSection + 1;
          canSwipe = currentSection < 14;
        }
        
        console.log(`üì± Processing ${direction} swipe: ${currentSection} ‚Üí ${targetSection}, canSwipe: ${canSwipe}`);
        
        if (canSwipe) {
          this.executeSwipeNavigation(targetSection);
        } else {
          this.showBoundaryFeedback(direction);
        }
      }
      
      executeSwipeNavigation(targetSection) {
        this.isTransitioning = true;
        this.lastSwipeTime = Date.now();
        
        this.showSwipeSuccess(targetSection > currentSection ? 'left' : 'right');
        
        transitionToSection(targetSection);
        
        setTimeout(() => {
          this.isTransitioning = false;
        }, 800);
      }
      
      showSwipePreview(deltaX) {
        // Could add subtle visual preview here if desired
      }
      
      hideSwipePreview() {
        // Reset any preview states
      }
      
      showSwipeSuccess(direction) {
        const indicator = document.getElementById(`swipeIndicator${direction === 'left' ? 'Left' : 'Right'}`);
        if (indicator) {
          indicator.classList.remove('boundary');
          indicator.classList.add('show');
          setTimeout(() => {
            indicator.classList.remove('show');
          }, 600);
        }
      }
      
      showBoundaryFeedback(direction) {
        const indicatorId = direction === 'right' ? 'swipeIndicatorLeft' : 'swipeIndicatorRight';
        const indicator = document.getElementById(indicatorId);
        
        if (indicator) {
          indicator.classList.add('boundary');
          indicator.textContent = direction === 'right' ? 'Start of tutorial' : 'End of tutorial';
          indicator.classList.add('show');
          
          setTimeout(() => {
            indicator.classList.remove('show');
            setTimeout(() => {
              indicator.classList.remove('boundary');
              indicator.textContent = direction === 'right' ? '‚Üê Previous' : 'Next ‚Üí';
            }, 200);
          }, 1000);
        }
      }
      
      destroy() {
        if (!isMobile) return;
        
        document.removeEventListener('touchstart', this.handleTouchStart);
        document.removeEventListener('touchmove', this.handleTouchMove);
        document.removeEventListener('touchend', this.handleTouchEnd);
      }
    }
    
    // Initialize swipe gestures
    let mobileSwipeGestures = null;

    // ==========================================
    // MOBILE MOTION CONTROL SYSTEM  
    // ==========================================
    
    class MobileMotionControl {
      constructor(tesseractShader) {
        this.tesseractShader = tesseractShader;
        this.isActive = false;
        this.isSupported = false;
        this.isPermissionGranted = false;
        this.isCalibrated = false;
        
        this.motionData = {
          alpha: 0,
          beta: 0,
          gamma: 0,
          calibration: { alpha: 0, beta: 0, gamma: 0 }
        };
        
        this.config = {
          sensitivity: 0.008,
          deadzone: 1,
          maxRotation: 2,
          smoothingFactor: 0.15,
          directMapping: true,
          gravityBias: 0.1
        };
        
        this.smoothedRotation = { x: 0, y: 0, w: 0 };
        this.lastRotation = { x: 0, y: 0, w: 0 };
        
        this.indicator = document.getElementById('motionIndicator');
        this.permissionPrompt = document.getElementById('motionPermissionPrompt');
        
        this.init();
      }
      
      async init() {
        if (!isMobile) return;
        
        console.log('üéØ Initializing mobile motion control');
        
        this.isSupported = 'DeviceOrientationEvent' in window;
        
        if (!this.isSupported) {
          console.log('‚ùå Device orientation not supported');
          return;
        }
        
        // Check for stored consent
        const storedConsent = localStorage.getItem('motionControlConsent');
        const hasStoredConsent = storedConsent === 'granted';
        
        if (this.indicator) {
          this.indicator.style.display = 'flex';
          this.indicator.addEventListener('click', this.toggleMotionControl.bind(this));
        }
        
        if (hasStoredConsent) {
          console.log('‚úÖ Found stored motion consent - auto-enabling');
          this.isPermissionGranted = true;
          this.startMotionDetection();
          this.autoEnableMotionControl();
          return;
        }
        
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          console.log('üì± iOS device detected - showing permission prompt');
          this.showPermissionPrompt();
        } else {
          console.log('üì± Android/older iOS - auto-enabling with stored consent');
          this.isPermissionGranted = true;
          this.startMotionDetection();
          this.autoEnableMotionControl();
          // Store consent for future visits
          localStorage.setItem('motionControlConsent', 'granted');
        }
      }
      
      autoEnableMotionControl() {
        // Auto-enable motion control and calibrate
        this.isActive = true;
        if (this.tesseractShader && typeof this.tesseractShader.enableMotionControl === 'function') {
          this.tesseractShader.enableMotionControl();
        }
        
        // Auto-calibrate after brief delay
        setTimeout(() => {
          this.calibrateMotion();
        }, 1500);
        
        console.log('üéØ Motion control auto-enabled from stored consent (no double-check)');
        console.log('üì± Device tilt will control hypercube rotation');
      }
      
      showPermissionPrompt() {
        if (!this.permissionPrompt) return;
        
        // Only show prompt for new users (no stored consent)
        const storedConsent = localStorage.getItem('motionControlConsent');
        if (storedConsent) return; // Don't show if already answered
        
        // Show prompt after brief delay, only for first-time visitors
        setTimeout(() => {
          if (currentSection === 0 && !this.isActive) {
            this.permissionPrompt.classList.add('show');
          }
        }, 2000); // Reduced delay since it's only for new users
        
        const enableBtn = document.getElementById('enableMotionBtn');
        const declineBtn = document.getElementById('declineMotionBtn');
        
        if (enableBtn) {
          enableBtn.addEventListener('click', this.requestPermission.bind(this));
        }
        
        if (declineBtn) {
          declineBtn.addEventListener('click', this.declinePermission.bind(this));
        }
      }
      
      async requestPermission() {
        try {
          const response = await DeviceOrientationEvent.requestPermission();
          
          if (response === 'granted') {
            console.log('‚úÖ Motion permission granted - storing consent');
            this.isPermissionGranted = true;
            
            // Store consent permanently
            localStorage.setItem('motionControlConsent', 'granted');
            
            this.startMotionDetection();
            this.hidePermissionPrompt();
            
            // Auto-enable motion control (no double-check)
            this.autoEnableMotionControl();
          } else {
            console.log('‚ùå Motion permission denied');
            localStorage.setItem('motionControlConsent', 'denied');
            this.handlePermissionDenied();
          }
        } catch (error) {
          console.error('Motion permission request failed:', error);
          this.handlePermissionDenied();
        }
      }
      
      declinePermission() {
        console.log('üë§ User declined motion control');
        localStorage.setItem('motionControlConsent', 'declined');
        this.hidePermissionPrompt();
      }
      
      hidePermissionPrompt() {
        if (this.permissionPrompt) {
          this.permissionPrompt.classList.remove('show');
        }
      }
      
      handlePermissionDenied() {
        this.hidePermissionPrompt();
        this.showFallbackMessage();
      }
      
      showFallbackMessage() {
        console.log('üì± Using touch controls as fallback');
      }
      
      startMotionDetection() {
        if (!this.isPermissionGranted) return;
        
        console.log('üéØ Starting motion detection');
        window.addEventListener('deviceorientation', this.handleDeviceOrientation.bind(this));
        
        if (this.indicator) {
          this.indicator.style.opacity = '0.7';
        }
      }
      
      calibrateMotion() {
        this.motionData.calibration = {
          alpha: this.motionData.alpha,
          beta: this.motionData.beta,
          gamma: this.motionData.gamma
        };
        
        this.isCalibrated = true;
        
        if (this.indicator) {
          this.indicator.classList.remove('calibrating');
          this.indicator.classList.add('active');
          this.indicator.title = 'Motion control active - tap to toggle';
          
          // Brief visual feedback
          this.indicator.style.transform = 'scale(1.2)';
          setTimeout(() => {
            this.indicator.style.transform = 'scale(1)';
          }, 400);
        }
        
        console.log('üéØ Motion control calibrated and ready');
      }
      
      toggleMotionControl() {
        // If no stored consent, show permission prompt
        const storedConsent = localStorage.getItem('motionControlConsent');
        if (!storedConsent || storedConsent === 'denied') {
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            this.showPermissionPrompt();
          }
          return;
        }
        
        // Toggle if we have permission
        if (!this.isSupported || !this.isPermissionGranted) return;
        
        this.isActive = !this.isActive;
        
        if (this.tesseractShader) {
          if (typeof this.tesseractShader.enableMotionControl === 'function') {
            if (this.isActive) {
              this.tesseractShader.enableMotionControl();
              console.log('üéØ Motion control manually ENABLED');
            } else {
              this.tesseractShader.disableMotionControl();
              console.log('üéØ Motion control manually DISABLED');
            }
          }
        }
        
        if (this.indicator) {
          if (this.isActive) {
            this.indicator.classList.add('active');
            this.indicator.title = 'Motion control active - tap to pause';
          } else {
            this.indicator.classList.remove('active');
            this.indicator.title = 'Motion control paused - tap to resume';
          }
        }
        
        // Update control panel button if it exists
        if (window.enhancedControlPanel && typeof window.enhancedControlPanel.updateMotionControlButton === 'function') {
          setTimeout(() => window.enhancedControlPanel.updateMotionControlButton(), 100);
        }
      }
      
      handleDeviceOrientation(event) {
        if (currentSection !== 0 || !this.isActive || !this.isCalibrated) {
          return;
        }
        
        this.motionData.alpha = event.alpha || 0;
        this.motionData.beta = event.beta || 0;
        this.motionData.gamma = event.gamma || 0;
        
        const deltaAlpha = this.normalizeAngle(this.motionData.alpha - this.motionData.calibration.alpha);
        const deltaBeta = this.motionData.beta - this.motionData.calibration.beta;
        const deltaGamma = this.motionData.gamma - this.motionData.calibration.gamma;
        
        const processedAlpha = Math.abs(deltaAlpha) > this.config.deadzone ? deltaAlpha : 0;
        const processedBeta = Math.abs(deltaBeta) > this.config.deadzone ? deltaBeta : 0;
        const processedGamma = Math.abs(deltaGamma) > this.config.deadzone ? deltaGamma : 0;
        
        if (this.config.directMapping) {
          const targetRotation = {
            x: -processedBeta * this.config.sensitivity * 2,
            y: processedGamma * this.config.sensitivity * 2,
            w: -processedAlpha * this.config.sensitivity * 1.5
          };
          
          targetRotation.x = this.clamp(targetRotation.x, -this.config.maxRotation, this.config.maxRotation);
          targetRotation.y = this.clamp(targetRotation.y, -this.config.maxRotation, this.config.maxRotation);
          targetRotation.w = this.clamp(targetRotation.w, -this.config.maxRotation, this.config.maxRotation);
          
          this.smoothedRotation.x = this.lerp(this.smoothedRotation.x, targetRotation.x, 1 - this.config.smoothingFactor);
          this.smoothedRotation.y = this.lerp(this.smoothedRotation.y, targetRotation.y, 1 - this.config.smoothingFactor);
          this.smoothedRotation.w = this.lerp(this.smoothedRotation.w, targetRotation.w, 1 - this.config.smoothingFactor);
          
        } else {
          const targetRotation = {
            x: processedBeta * this.config.sensitivity,
            y: processedGamma * this.config.sensitivity,
            w: processedAlpha * this.config.sensitivity
          };
          
          targetRotation.x = this.clamp(targetRotation.x, -this.config.maxRotation, this.config.maxRotation);
          targetRotation.y = this.clamp(targetRotation.y, -this.config.maxRotation, this.config.maxRotation);
          targetRotation.w = this.clamp(targetRotation.w, -this.config.maxRotation, this.config.maxRotation);
          
          this.smoothedRotation.x = this.lerp(this.smoothedRotation.x, targetRotation.x, 1 - this.config.smoothingFactor);
          this.smoothedRotation.y = this.lerp(this.smoothedRotation.y, targetRotation.y, 1 - this.config.smoothingFactor);
          this.smoothedRotation.w = this.lerp(this.smoothedRotation.w, targetRotation.w, 1 - this.config.smoothingFactor);
        }
        
        const gravityInfluence = Math.sin(deltaBeta * Math.PI / 180) * this.config.gravityBias;
        this.smoothedRotation.x += gravityInfluence * 0.005;
        
        this.applyMotionToShader();
      }
      
      applyMotionToShader() {
        if (!this.tesseractShader) return;
        
        if (typeof this.tesseractShader.updateMotionInput === 'function') {
          this.tesseractShader.updateMotionInput({
            x: this.smoothedRotation.x * 0.015,
            y: this.smoothedRotation.y * 0.015,
            w: this.smoothedRotation.w * 0.01
          });
        } else {
          console.warn('Using fallback motion control - enhanced shader not detected');
          
          if (this.tesseractShader.slowVelocity) {
            this.tesseractShader.slowVelocity.x = this.smoothedRotation.x * 0.3;
            this.tesseractShader.slowVelocity.y = this.smoothedRotation.y * 0.3;
          }
          
          if (this.tesseractShader.wheelVelocity !== undefined) {
            this.tesseractShader.wheelVelocity += this.smoothedRotation.w * 0.15;
          }
        }
      }
      
      normalizeAngle(angle) {
        while (angle > 180) angle -= 360;
        while (angle < -180) angle += 360;
        return angle;
      }
      
      clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }
      
      lerp(a, b, t) {
        return a + (b - a) * t;
      }
      
      disable() {
        this.isActive = false;
        
        if (this.tesseractShader && typeof this.tesseractShader.disableMotionControl === 'function') {
          this.tesseractShader.disableMotionControl();
        }
        
        if (this.indicator) {
          this.indicator.classList.remove('active');
          this.indicator.style.opacity = '0.4';
        }
      }
      
      enable() {
        if (this.isSupported && this.isPermissionGranted && currentSection === 0) {
          if (this.indicator) {
            this.indicator.style.opacity = '0.7';
          }
        }
      }
      
      destroy() {
        if (!isMobile) return;
        
        window.removeEventListener('deviceorientation', this.handleDeviceOrientation);
        
        if (this.indicator) {
          this.indicator.removeEventListener('click', this.toggleMotionControl);
        }
      }
    }
    
    // Initialize motion control
    let mobileMotionControl = null;
    
    // Make motion control globally accessible for control panel integration
    window.mobileMotionControl = null;

    // ==========================================
    // EXISTING TUTORIAL FUNCTIONALITY
    // ==========================================

    // Data loading state
    let dataLoaded = {
      tsv: false,
      rotationGLSL: false,
      perspectiveGLSL: false,
      lineDistanceGLSL: false
    };

    // Initialize Tesseract Shader instance and Enhanced Control Panel
    let tesseractShader = null;
    let enhancedControlPanel = null;

    // Load tutorial content from external file
    function loadTutorialContent() {
      console.log('üìÑ Loading tutorial content...');
      
      return fetch('contentTesseract.html')
        .then(response => {
          console.log('üìÑ Content fetch response:', response.status, response.ok);
          if (!response.ok) {
            throw new Error(`Failed to load tutorial content: ${response.status}`);
          }
          return response.text();
        })
        .then(html => {
          console.log('üìÑ Content loaded, length:', html.length);
          document.getElementById('tutorialContainer').outerHTML = html;
          console.log('‚úÖ Tutorial content loaded successfully');
        })
        .catch(error => {
          console.error('‚ùå Error loading tutorial content:', error);
          // Fallback content
          const fallbackHTML = `
            <div class="tutorial-container" id="tutorialContainer">
              <div class="tutorial-header">
                <div class="tutorial-title" id="currentSectionTitle">Tutorial Loading Error</div>
                <div class="tutorial-nav">
                  <button class="nav-btn" onclick="goToPrevSection()">‚Üê</button>
                  <button class="nav-btn" onclick="goToNextSection()">‚Üí</button>
                  <button class="nav-btn close-btn" onclick="closeTutorial()">√ó</button>
                </div>
              </div>
              <div class="tutorial-content">
                <div class="tutorial-scroller" id="tutorialScroller">
                  <div class="tutorial-section">
                    <div style="padding: 2rem; text-align: center;">
                      <p>Tutorial content could not be loaded. Using basic fallback.</p>
                      <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #00ffff; color: #000; border: none; border-radius: 5px; cursor: pointer;">
                        Reload Page
                      </button>
                    </div>
                  </div>
                </div>
                <div class="static-image-container" id="staticImageContainer">
                  <div class="image-transition-container" id="imageTransitionContainer"></div>
                  <div id="hotspotContainer"></div>
                </div>
              </div>
            </div>
            
            <div class="progress-bar" id="progressBar" style="display: none;"></div>
            
            <div class="parameter-dialog" id="parameterDialog">
              <h3 id="parameterTitle">Parameters</h3>
              <div id="parameterContent">No parameters available</div>
            </div>
          `;
          
          document.getElementById('tutorialContainer').outerHTML = fallbackHTML;
          console.log('‚ö†Ô∏è Using fallback tutorial content');
        });
    }

    // Load dynamic content
    function loadDynamicContent() {
      // TSV loader
      fetch('https://raw.githubusercontent.com/TrueFiasco/website/main/Tesseract%20Tutorial%20Pictures/code/euler%20cycle.tsv')
        .then(res => {
          if (!res.ok) throw new Error('Failed to load TSV');
          return res.text();
        })
        .then(tsv => {
          const rows = tsv.trim().split('\n');
          const headers = rows[0].split('\t');
          const dataRows = rows.slice(1);
          
          const thead = document.querySelector('#tsvTable thead tr');
          if (thead) {
            thead.innerHTML = '';
            headers.forEach(header => {
              const th = document.createElement('th');
              th.textContent = header.trim();
              thead.appendChild(th);
            });
            
            const tbody = document.querySelector('#tsvTable tbody');
            if (tbody) {
              tbody.innerHTML = '';
              dataRows.forEach(row => {
                const cells = row.split('\t');
                const tr = document.createElement('tr');
                cells.forEach(cell => {
                  const td = document.createElement('td');
                  td.textContent = cell.trim();
                  tr.appendChild(td);
                });
                tbody.appendChild(tr);
              });
            }
          }
          dataLoaded.tsv = true;
        })
        .catch(err => {
          console.error('Failed to load TSV:', err);
          const tbody = document.querySelector('#tsvTable tbody');
          if (tbody) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #ff6b6b; font-style: italic;">Failed to load TSV data</td></tr>';
          }
        });

      // Code snippet loaders
      const codeSnippets = [
        {
          id: 'rotationGLSLContent',
          url: 'https://raw.githubusercontent.com/TrueFiasco/website/main/Tesseract%20Tutorial%20Pictures/code/vert_rotation_pixel.frag',
          key: 'rotationGLSL'
        },
        {
          id: 'perspectiveGLSLContent', 
          url: 'https://raw.githubusercontent.com/TrueFiasco/website/main/Tesseract%20Tutorial%20Pictures/code/vert_persprective_pixel.frag',
          key: 'perspectiveGLSL'
        },
        {
          id: 'lineDistanceGLSLContent',
          url: 'https://raw.githubusercontent.com/TrueFiasco/website/main/Tesseract%20Tutorial%20Pictures/code/line_mindist_pixel.frag',
          key: 'lineDistanceGLSL'
        }
      ];

      codeSnippets.forEach(snippet => {
        fetch(snippet.url)
          .then(res => {
            if (!res.ok) throw new Error(`Failed to load ${snippet.key}`);
            return res.text();
          })
          .then(code => {
            const el = document.getElementById(snippet.id)?.querySelector('.code-content');
            if (el) {
              el.textContent = code;
              el.classList.remove('loading');
              dataLoaded[snippet.key] = true;
            }
          })
          .catch(err => {
            console.error(`Failed to load ${snippet.key}:`, err);
            const el = document.getElementById(snippet.id)?.querySelector('.code-content');
            if (el) {
              el.textContent = `Failed to load ${snippet.key} code`;
              el.classList.remove('loading');
              el.classList.add('error');
            }
          });
      });
    }

    function updateSectionPadding(sectionIndex) {
      const section = document.querySelector(`#tutorialScroller .tutorial-section:nth-child(${sectionIndex})`);
      if (!section) return;
      
      const config = sectionConfig[sectionIndex];
      const hasBackgroundImage = config && config.image;
      
      if (hasBackgroundImage) {
        section.classList.add('has-background-image');
      } else {
        section.classList.remove('has-background-image');
      }
    }

    // Image transition functions
    function transitionToSection(newSection) {
      if (newSection === currentSection) return;
      
      currentSection = newSection;
      
      updateSectionTitle();
      updateTutorial();
      
      if (currentSection > 0 && currentSection <= 14) {
        transitionStaticImage(currentSection);
      }
    }

    function updateSectionTitle() {
      const titleElement = document.getElementById('currentSectionTitle');
      if (titleElement && currentSection >= 0 && currentSection < sectionTitles.length) {
        titleElement.textContent = sectionTitles[currentSection];
      }
    }

    let currentTransition = null;
    let transitionCounter = 0;

    function transitionStaticImage(newSection) {
      const config = sectionConfig[newSection];
      if (!config) return;
    
      const imageContainer = document.getElementById('staticImageContainer');
      if (!imageContainer) return;
    
      updateSectionPadding(newSection);
      
      if (currentTransition) {
        currentTransition.cancelled = true;
      }
      
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }

      const transitionId = ++transitionCounter;
      currentTransition = { id: transitionId, cancelled: false };
      
      const existingImages = imageContainer.querySelectorAll('.tutorial-image');
      const currentImage = existingImages.length > 0 ? existingImages[existingImages.length - 1] : null;
      
      const newImage = document.createElement('img');
      newImage.className = 'tutorial-image';
      newImage.style.aspectRatio = config.aspectRatio.replace(':', '/');
      newImage.src = config.image;
      newImage.dataset.transitionId = transitionId;

      if (config.offset.x === 0 && config.offset.y === 0) {
        newImage.style.transform = 'translate(0, 0)';
        newImage.style.opacity = '0';
        newImage.style.zIndex = '10';
      } else {
        const startX = config.offset.x * 100;
        const startY = config.offset.y * 100;
        newImage.style.transform = `translate(${startX}%, ${startY}%)`;
        newImage.style.opacity = '0';
        newImage.style.zIndex = '10';
      }

      if (currentImage) {
        currentImage.style.zIndex = '5';
      }

      imageContainer.appendChild(newImage);
      
      function executeTransition() {
        if (currentTransition.cancelled || currentTransition.id !== transitionId) {
          newImage.remove();
          return;
        }
        
        updateHotspots(config.hotspots);

        setTimeout(() => {
          if (currentTransition.cancelled || currentTransition.id !== transitionId) {
            newImage.remove();
            return;
          }

          newImage.style.opacity = '1';
          newImage.style.transform = 'translate(0, 0)';

          if (currentImage && currentImage.parentNode === imageContainer) {
            if (config.offset.x === 0 && config.offset.y === 0) {
              currentImage.style.opacity = '0';
            } else {
              const exitX = -config.offset.x * 100;
              const exitY = -config.offset.y * 100;
              currentImage.style.transform = `translate(${exitX}%, ${exitY}%)`;
              currentImage.style.opacity = '0';
            }
          }

          cleanupTimeout = setTimeout(() => {
            if (currentTransition.id === transitionId) {
              const allImages = imageContainer.querySelectorAll('.tutorial-image');
              allImages.forEach(img => {
                if (img !== newImage && img.parentNode === imageContainer) {
                  imageContainer.removeChild(img);
                }
              });
              
              if (currentTransition.id === transitionId) {
                currentTransition = null;
              }
            }
            cleanupTimeout = null;
          }, 850);
        }, 10);
      }
      
      if (newImage.complete) {
        executeTransition();
      } else {
        newImage.onload = executeTransition;
        newImage.onerror = () => {
          console.error('Failed to load image:', config.image);
          if (currentTransition.id === transitionId) {
            newImage.remove();
            currentTransition = null;
          }
        };
      }
    }

    function updateHotspots(hotspots) {
      const hotspotContainer = document.getElementById('hotspotContainer');
      if (!hotspotContainer) return;

      stickyHotspots.clear();
      hotspotContainer.innerHTML = '';

      if (isMobile) return;

      hotspots.forEach((hotspot, index) => {
        const element = document.createElement('div');
        element.className = 'hotspot';
        element.style.top = hotspot.top;
        element.style.left = hotspot.left;
        element.style.pointerEvents = 'auto';
        element.dataset.hotspotId = index;
        
        element.onmouseenter = () => showParameterDialog(element, hotspot.type);
        element.onmouseleave = () => {
          if (!stickyHotspots.has(index)) {
            hideParameterDialog();
          }
        };
        element.onclick = () => {
          const hotspotId = parseInt(element.dataset.hotspotId);
          if (stickyHotspots.has(hotspotId)) {
            stickyHotspots.delete(hotspotId);
            element.classList.remove('sticky');
            hideParameterDialog();
          } else {
            stickyHotspots.add(hotspotId);
            element.classList.add('sticky');
            showParameterDialog(element, hotspot.type);
          }
        };
        
        hotspotContainer.appendChild(element);
      });
    }

    function updateTutorial() {
      const scroller = document.getElementById('tutorialScroller');
      const tutorialContainer = document.getElementById('tutorialContainer');
      const progressBar = document.getElementById('progressBar');
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      
      if (currentSection === 0) {
        if (tutorialContainer) {
          tutorialContainer.classList.remove('active');
        }
        if (progressBar) {
          progressBar.style.display = 'none';
        }
        
        if (mobileBtn && isMobile) {
          mobileBtn.style.display = 'block';
          mobileBtn.style.opacity = '1';
          mobileBtn.style.visibility = 'visible';
          mobileBtn.style.pointerEvents = 'auto';
        }
        
        if (mobileMotionControl && isMobile) {
          mobileMotionControl.enable();
        }
        
        tutorialOpen = false;
      } else {
        if (tutorialContainer) {
          tutorialContainer.classList.add('active');
        }
        if (progressBar) {
          progressBar.style.display = 'flex';
        }
        
        if (mobileBtn) {
          mobileBtn.style.opacity = '0';
          mobileBtn.style.visibility = 'hidden';
          mobileBtn.style.pointerEvents = 'none';
        }
        
        if (mobileMotionControl && isMobile) {
          mobileMotionControl.disable();
        }
        
        tutorialOpen = true;
        if (scroller) {
          const offset = (currentSection - 1) * -100;
          scroller.style.transform = `translateX(${offset}vw)`;
        }
        
        updateSectionPadding(currentSection);
      }
      
      updateProgressBar();
    }

    // Navigation functions
    function openTutorial() {
      console.log('üöÄ openTutorial called - starting tutorial!');
      
      try {
        if (cleanupTimeout) {
          clearTimeout(cleanupTimeout);
          cleanupTimeout = null;
        }
        
        const mobileBtn = document.getElementById('mobileTutorialBtn');
        if (mobileBtn) {
          mobileBtn.style.opacity = '0';
          mobileBtn.style.visibility = 'hidden';
          mobileBtn.style.pointerEvents = 'none';
        }
        
        transitionToSection(1);
        initProgressBar();
        
        console.log('‚úÖ Tutorial opened successfully');
      } catch (error) {
        console.error('‚ùå Error opening tutorial:', error);
      }
    }

    function closeTutorial() {
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }
      
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      if (mobileBtn && isMobile) {
        mobileBtn.style.opacity = '1';
        mobileBtn.style.visibility = 'visible';
        mobileBtn.style.pointerEvents = 'auto';
      }
      
      transitionToSection(0);
    }

    function goToHero() {
      closeTutorial();
    }

    function goToTutorialsPage() {
      window.open('https://truefiasco.org/tutorials', '_blank');
    }

    function goToNextSection() {
      if (currentSection < 14) {
        transitionToSection(currentSection + 1);
      }
    }

    function goToPrevSection() {
      if (currentSection > 1) {
        transitionToSection(currentSection - 1);
      }
    }

    function downloadTesseractResources() {
      window.open('https://github.com/TrueFiasco/TouchDesigner-Tesseract-Tutorial', '_blank');
    }
    
    // Make key functions available globally
    window.openTutorial = openTutorial;
    window.closeTutorial = closeTutorial;
    window.goToNextSection = goToNextSection;
    window.goToPrevSection = goToPrevSection;

    function initProgressBar() {
      const progressBar = document.getElementById('progressBar');
      if (progressBar) {
        progressBar.innerHTML = '';
        
        for (let i = 1; i <= 14; i++) {
          const dot = document.createElement('div');
          dot.className = 'progress-dot';
          if (i === currentSection) dot.classList.add('active');
          dot.onclick = () => transitionToSection(i);
          progressBar.appendChild(dot);
        }
      }
    }

    function updateProgressBar() {
      const dots = document.querySelectorAll('.progress-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', (index + 1) === currentSection);
      });
    }

    // Enhanced parameter dialog functions
    function showParameterDialog(element, type) {
      const dialog = document.getElementById('parameterDialog');
      const title = document.getElementById('parameterTitle');
      const content = document.getElementById('parameterContent');
      
      if (!dialog || !title || !content) return;
      
      const parameterData = {
        'math1-params': { title: 'Math1 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/math1.png' },
        'mousein1-wheel': { title: 'MouseIn1 CHOP - Wheel Channel', image: 'Tesseract%20Tutorial%20Pictures/parameters/mousein1.png' },
        'select2-params': { title: 'Select2 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/select2.png' },
        'filter2-params': { title: 'Filter2 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/filter2.png' },
        'filter3-params': { title: 'Filter3 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/filter3.png' },
        'filter4-params': { title: 'Filter4 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/filter4.png' },
        'vert_rotation': { title: 'Vertex Rotation GLSL Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/vert_rotation.png' },
        'vert_perspective': { title: 'Vertex Perspective GLSL Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/vert_perspective.png' },
        'transform1': { title: 'Transform1 TOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/transform1.png' },
        'reorder1': { title: 'Reorder1 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/reorder1.png' },
        'line_mindist': { title: 'SDF Line Min Distance Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/line_mindist.png' },
        'limits-params': { title: 'Limits TOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/limits.png' },
        'ramp-params': { title: 'Ramp TOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/ramp.png' },
        'lookup-params': { title: 'Lookup TOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/lookup.png' },
        'select1-detailed': { title: 'Select1 CHOP - Channel Selection', image: 'Tesseract%20Tutorial%20Pictures/parameters/select1.png' },
        'math3-params': { title: 'Math3 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/math3.png' },
        'filter1-params': { title: 'Filter1 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/filter1.png' },
        'speed2-params': { title: 'Speed2 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/speed2.png' },
        'math2-params': { title: 'Math2 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/math2.png' },
        'speed3-params': { title: 'Speed3 CHOP Parameters', params: ['Integration method', 'Velocity to position', 'Frame rate: 60Hz'] }
      };
      
      const data = parameterData[type] || { title: 'Parameters', params: ['Custom parameters will be shown here'] };
      
      title.textContent = data.title;
      
      if (data.image) {
        content.innerHTML = `<img src="${data.image}" style="width: 100%; max-width: 525px; border-radius: 5px;" alt="${data.title}">`;
      } else if (data.params) {
        content.innerHTML = data.params.map(param => `<div class="parameter-item">${param}</div>`).join('');
      } else {
        content.innerHTML = '<div class="parameter-item">No parameters available</div>';
      }
      
      // Smart positioning logic
      const rect = element.getBoundingClientRect();
      const dialogWidth = 600;
      const dialogHeight = 400;
      const padding = 20;
      
      let left = rect.left + 45;
      let top = rect.top - 50;
      
      if (left + dialogWidth > window.innerWidth - padding) {
        left = rect.left - dialogWidth - 10;
      }
      
      if (left < padding) {
        left = padding;
      }
      
      if (top < padding) {
        top = rect.bottom + 10;
      }
      
      if (top + dialogHeight > window.innerHeight - padding) {
        top = window.innerHeight - dialogHeight - padding;
      }
      
      dialog.style.left = `${left}px`;
      dialog.style.top = `${top}px`;
      dialog.classList.add('active');
    }

    function hideParameterDialog() {
      const dialog = document.getElementById('parameterDialog');
      if (dialog) {
        dialog.classList.remove('active');
      }
      
      stickyHotspots.clear();
      document.querySelectorAll('.hotspot.sticky').forEach(hotspot => {
        hotspot.classList.remove('sticky');
      });
    }

    // Widget fullscreen functions (keeping existing code)
    function showTSVFullscreen() {
      const modal = document.getElementById('tsvFullscreen');
      const content = document.getElementById('tsvFullscreenContent');
      if (modal && content) {
        const tsvContent = document.getElementById('tsvContent');
        if (tsvContent) {
          content.innerHTML = tsvContent.innerHTML;
        }
        modal.classList.add('active');
      }
    }

    function closeTSVFullscreen() {
      const modal = document.getElementById('tsvFullscreen');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    function showRotationGLSLFullscreen() {
      const modal = document.getElementById('rotationGLSLFullscreen');
      const content = document.getElementById('rotationGLSLFullscreenContent');
      
      if (modal && content) {
        const originalCodeContent = document.querySelector('#rotationGLSLContent .code-content');
        if (originalCodeContent) {
          const codeText = originalCodeContent.textContent;
          content.innerHTML = `<div class="code-content" style="height: auto; overflow: visible; white-space: pre-wrap;">${codeText}</div>`;
        }
        modal.classList.add('active');
      }
    }

    function closeRotationGLSLFullscreen() {
      const modal = document.getElementById('rotationGLSLFullscreen');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    function showPerspectiveGLSLFullscreen() {
      const modal = document.getElementById('perspectiveGLSLFullscreen');
      const content = document.getElementById('perspectiveGLSLFullscreenContent');
      
      if (modal && content) {
        const originalCodeContent = document.querySelector('#perspectiveGLSLContent .code-content');
        if (originalCodeContent) {
          const codeText = originalCodeContent.textContent;
          content.innerHTML = `<div class="code-content" style="height: auto; overflow: visible; white-space: pre-wrap;">${codeText}</div>`;
        }
        modal.classList.add('active');
      }
    }

    function closePerspectiveGLSLFullscreen() {
      const modal = document.getElementById('perspectiveGLSLFullscreen');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    function showLineDistanceGLSLFullscreen() {
      const modal = document.getElementById('lineDistanceGLSLFullscreen');
      const content = document.getElementById('lineDistanceGLSLFullscreenContent');
      
      if (modal && content) {
        const originalCodeContent = document.querySelector('#lineDistanceGLSLContent .code-content');
        if (originalCodeContent) {
          const codeText = originalCodeContent.textContent;
          content.innerHTML = `<div class="code-content" style="height: auto; overflow: visible; white-space: pre-wrap;">${codeText}</div>`;
        }
        modal.classList.add('active');
      }
    }

    function closeLineDistanceGLSLFullscreen() {
      const modal = document.getElementById('lineDistanceGLSLFullscreen');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    // Copy notification helper
    function showCopyNotification() {
      const notification = document.getElementById('copyNotification');
      if (notification) {
        notification.classList.add('show');
        setTimeout(() => {
          notification.classList.remove('show');
        }, 2000);
      }
    }

    // Copy to clipboard functions (keeping existing code)
    function copyTSVToClipboard() {
      const table = document.getElementById('tsvTable');
      if (!table) return;
      
      let tsvText = '';
      
      const headerCells = table.getElementsByTagName('thead')[0]?.getElementsByTagName('th');
      if (headerCells) {
        const headers = [];
        for (let header of headerCells) {
          headers.push(header.textContent);
        }
        tsvText += headers.join('\t') + '\n';
      }
      
      const rows = table.getElementsByTagName('tbody')[0]?.getElementsByTagName('tr');
      if (rows) {
        for (let row of rows) {
          const cells = row.getElementsByTagName('td');
          const rowData = [];
          for (let cell of cells) {
            rowData.push(cell.textContent);
          }
          tsvText += rowData.join('\t') + '\n';
        }
      }
      
      navigator.clipboard.writeText(tsvText).then(() => {
        showCopyNotification();
      }).catch(err => {
        console.error('Failed to copy TSV data: ', err);
      });
    }

    function copyRotationGLSLToClipboard() {
      const fullscreenModal = document.getElementById('rotationGLSLFullscreen');
      let codeContent;
      
      if (fullscreenModal && fullscreenModal.classList.contains('active')) {
        codeContent = document.querySelector('#rotationGLSLFullscreenContent .code-content');
      } else {
        codeContent = document.querySelector('#rotationGLSLContent .code-content');
      }
      
      if (codeContent) {
        const text = codeContent.textContent;
        
        navigator.clipboard.writeText(text).then(() => {
          showCopyNotification();
        }).catch(err => {
          console.error('Failed to copy rotation GLSL code: ', err);
        });
      }
    }

    function copyPerspectiveGLSLToClipboard() {
      const fullscreenModal = document.getElementById('perspectiveGLSLFullscreen');
      let codeContent;
      
      if (fullscreenModal && fullscreenModal.classList.contains('active')) {
        codeContent = document.querySelector('#perspectiveGLSLFullscreenContent .code-content');
      } else {
        codeContent = document.querySelector('#perspectiveGLSLContent .code-content');
      }
      
      if (codeContent) {
        const text = codeContent.textContent;
        
        navigator.clipboard.writeText(text).then(() => {
          showCopyNotification();
        }).catch(err => {
          console.error('Failed to copy perspective GLSL code: ', err);
        });
      }
    }

    function copyLineDistanceGLSLToClipboard() {
      const fullscreenModal = document.getElementById('lineDistanceGLSLFullscreen');
      let codeContent;
      
      if (fullscreenModal && fullscreenModal.classList.contains('active')) {
        codeContent = document.querySelector('#lineDistanceGLSLFullscreenContent .code-content');
      } else {
        codeContent = document.querySelector('#lineDistanceGLSLContent .code-content');
      }
      
      if (codeContent) {
        const text = codeContent.textContent;
        
        navigator.clipboard.writeText(text).then(() => {
          showCopyNotification();
        }).catch(err => {
          console.error('Failed to copy line distance GLSL code: ', err);
        });
      }
    }

    function onWheel(event) {
      const anyModalOpen = document.querySelector('.widget-fullscreen.active');
      
      if (anyModalOpen) {
        return;
      }
    
      if (tutorialOpen) {
        event.preventDefault();
        const delta = event.deltaY;
        
        if (delta > 0) {
          goToNextSection();
        } else {
          goToPrevSection();
        }
        return;
      }
    }

    function setupMobileButton() {
      console.log('üì± Setting up mobile button, isMobile:', isMobile);
      
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      const startBtn = document.getElementById('mobileStartBtn');
      
      console.log('Mobile button elements found:', { mobileBtn: !!mobileBtn, startBtn: !!startBtn });
      
      if (isMobile) {
        if (mobileBtn && startBtn) {
          mobileBtn.style.display = 'block';
          mobileBtn.style.visibility = 'visible';
          mobileBtn.style.opacity = '1';
          mobileBtn.style.pointerEvents = 'auto';
          
          startBtn.style.pointerEvents = 'auto';
          startBtn.style.zIndex = '2000';
          
          startBtn.addEventListener('click', function(e) {
            console.log('üì± Mobile start button clicked');
            e.preventDefault();
            e.stopPropagation();
            openTutorial();
          });
          
          console.log('‚úÖ Mobile button setup complete');
        } else {
          console.warn('‚ö†Ô∏è Mobile button elements not found');
        }
      } else {
        // Hide button on desktop
        if (mobileBtn) {
          mobileBtn.style.display = 'none';
        }
        console.log('üñ•Ô∏è Desktop mode - mobile button hidden');
      }
    }

    async function init() {
      try {
        console.log('üöÄ Starting tutorial initialization...');
        
        // Load tutorial content first
        await loadTutorialContent();
        console.log('‚úÖ Tutorial content loaded');
        
        // Check if Three.js loaded
        if (typeof THREE === 'undefined') {
          throw new Error('Three.js not loaded');
        }
        console.log('‚úÖ Three.js available');
        
        // Check if TesseractShader is available
        if (typeof TesseractShader === 'undefined') {
          throw new Error('TesseractShader not loaded');
        }
        console.log('‚úÖ TesseractShader available');
        
        // Initialize Tesseract shader
        tesseractShader = new TesseractShader('hypercube-canvas', {
          onTutorialOpen: openTutorial,
          getTutorialState: () => tutorialOpen
        });
        
        await tesseractShader.init();
        console.log('‚úÖ TesseractShader initialized');
        
        // Initialize Enhanced Control Panel
        enhancedControlPanel = new EnhancedControlPanel(tesseractShader);
        window.enhancedControlPanel = enhancedControlPanel; // Make globally accessible
        console.log('‚úÖ Enhanced Control Panel initialized');
        
        // Test desktop click functionality
        if (!isMobile) {
          console.log('üñ•Ô∏è Desktop mode - click anywhere on hero section to start tutorial');
        }
        
        loadDynamicContent();
        initProgressBar();
        updateSectionTitle();
        setupMobileButton();
        
        // Initialize mobile features (with error handling)
        if (isMobile) {
          try {
            mobileSwipeGestures = new MobileSwipeGestures();
            console.log('‚úÖ Mobile swipe gestures initialized');
          } catch (error) {
            console.warn('‚ö†Ô∏è Mobile swipe gestures failed to initialize:', error);
          }
          
          try {
            mobileMotionControl = new MobileMotionControl(tesseractShader);
            window.mobileMotionControl = mobileMotionControl; // Make globally accessible
            console.log('‚úÖ Mobile motion control initialized');
          } catch (error) {
            console.warn('‚ö†Ô∏è Mobile motion control failed to initialize:', error);
          }
        }
        
        // Setup wheel event for tutorial navigation
        document.addEventListener('wheel', onWheel, { passive: false });
        
        console.log('üéâ Tutorial initialization complete!');
      } catch (error) {
        console.error('‚ùå Failed to initialize tutorial application:', error);
        
        // Basic fallback UI
        const heroSection = document.getElementById('heroSection');
        if (heroSection) {
          heroSection.innerHTML += `
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                        background: rgba(255, 0, 0, 0.8); color: white; padding: 2rem; border-radius: 10px;
                        text-align: center; z-index: 9999;">
              <h2>Loading Error</h2>
              <p>Failed to initialize tutorial: ${error.message}</p>
              <button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; 
                      background: white; color: black; border: none; border-radius: 5px; cursor: pointer;">
                Reload Page
              </button>
            </div>
          `;
        }
      }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    // Close modals with escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeTSVFullscreen();
        closeRotationGLSLFullscreen();
        closePerspectiveGLSLFullscreen();
        closeLineDistanceGLSLFullscreen();
        hideParameterDialog();
      }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (mobileSwipeGestures) {
        mobileSwipeGestures.destroy();
      }
      if (mobileMotionControl) {
        mobileMotionControl.destroy();
      }
      if (tesseractShader) {
        tesseractShader.destroy();
      }
    });
  </script>
</body>
</html>
