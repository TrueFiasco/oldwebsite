<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tesseract Tutorial - Interactive TouchDesigner Guide</title>
  <link rel="stylesheet" href="layoutTesseract.css" />
</head>
<body>
  <!-- Hero Section -->
  <div class="hero-section" id="heroSection">
    <canvas class="hypercube-canvas" id="hypercube-canvas"></canvas>
    <button class="nav-btn close-btn" onclick="window.history.back()" style="position: absolute; top: 2rem; right: 2rem; z-index: 100;">Ã—</button>
    
    <!-- Hero Settings Toggle -->
    <div class="hero-settings-toggle" id="heroSettingsToggle">
      <svg viewBox="0 0 24 24">
        <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11.03L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11.03C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
      </svg>
    </div>
  
    <!-- Hero Controls Panel -->
    <div class="hero-controls-panel" id="heroControlsPanel">
      <h4>4D Projection Controls</h4>
      <div class="control-group">
        <label for="hero-fov-control">FOV:</label>
        <input type="number" id="hero-fov-control" value="7" step="1" min="2" max="120">
      </div>
      <div class="control-group">
        <label for="hero-perspective-control">4D Scale:</label>
        <input type="number" id="hero-perspective-control" value="2.3" step="0.1" min="0.1" max="10">
      </div>
      <div class="control-group">
        <label for="hero-cameraz-control">Camera Z:</label>
        <input type="number" id="hero-cameraz-control" value="10" step="1" min="-100" max="50">
      </div>
    </div>
    
    <div class="hero-content">
      <!-- Hidden HTML titles - only shader text will be visible on both desktop and mobile -->
      <h1 class="hero-title" style="opacity: 0; pointer-events: none; position: absolute; visibility: hidden;">TESSERACT</h1>
      <p class="hero-subtitle" style="opacity: 0; pointer-events: none; position: absolute; visibility: hidden;">TouchDesigner Tutorial using GLSL<br>Interactive 4D Hypercube Visualization</p>
    </div>
  </div>
  
  <!-- Mobile-only tutorial button - moved outside hero section to prevent z-index conflicts -->
  <div class="mobile-tutorial-button" id="mobileTutorialBtn">
    <button class="mobile-start-btn" onclick="openTutorial()">
      Start Tutorial
    </button>
  </div>
  
  <!-- Tutorial Container Placeholder - will be loaded dynamically -->
  <div id="tutorialContainer"></div>
  
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Tesseract Shader Module -->
  <script src="shaderTesseract.js"></script>

  <script>
    // Tutorial Section Configuration
    const sectionConfig = {
      1: { 
        aspectRatio: "3615:1097", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/network_overview.png",
        hotspots: []
      },
      2: { 
        aspectRatio: "1852:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/chop_network.png",
        hotspots: []
      },
      3: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/mouse_uv_control.png",
        hotspots: [
          { top: "35%", left: "17%", type: "select1-detailed" }
        ]
      },
      4: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/mouse_velocity.png",
        hotspots: [
          { top: "4%", left: "29%", type: "math3-params" },
          { top: "4%", left: "52%", type: "filter1-params" }
        ]
      },
      5: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/centering_and_scaling.png",
        hotspots: [
          { top: "35%", left: "29%", type: "math1-params" },
          { top: "35%", left: "41%", type: "speed2-params" }
        ]
      },
      6: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/angular_velocity.png",
        hotspots: [
          { top: "30%", left: "65%", type: "math2-params" },
          { top: "28%", left: "76%", type: "speed3-params" }
        ]
      },
      7: { 
        aspectRatio: "1852:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/mouse_wheel.png",
        hotspots: [
          { top: "67%", left: "3%", type: "mousein1-wheel" },
          { top: "67%", left: "15%", type: "select2-params" },
          { top: "67%", left: "29%", type: "filter4-params" },
          { top: "67%", left: "41%", type: "filter3-params" },
          { top: "67%", left: "53%", type: "filter2-params" }
        ]
      },
      8: { 
        aspectRatio: "1852:571", 
        offset: {x: 0.1, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/merging_and_null.png",
        hotspots: []
      },
      9: { 
        aspectRatio: "1456:478", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/euler_in.png",
        hotspots: []
      },
      10: { 
        aspectRatio: "1920:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/rotate_vertex_glsl.png",
        hotspots: [
          { top: "35%", left: "40%", type: "vert_rotation" }
        ]
      },
      11: { 
        aspectRatio: "1920:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/prespective_glsl.png",
        hotspots: [
          { top: "40%", left: "50%", type: "vert_perspective" }
        ]
      },
      12: { 
        aspectRatio: "1920:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/2d_points_to_2d_lines.png",
        hotspots: [
          { top: "45%", left: "35%", type: "transform1" },
          { top: "45%", left: "65%", type: "reorder1" }
        ]
      },
      13: { 
        aspectRatio: "1920:571", 
        offset: {x: 0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/sdf_uneven_capsule.png",
        hotspots: [
          { top: "50%", left: "50%", type: "line_mindist" }
        ]
      },
      14: { 
        aspectRatio: "1920:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/post_processing.png",
        hotspots: []
      }
    };

    // Section titles for header
    const sectionTitles = [
      "TESSERACT Tutorial",
      "TESSERACT Overview", 
      "The CHOP Network",
      "Input Data 1: Mouse UV Control",
      "Rangeling CHOPs 1: Mouse Velocity",
      "Rangeling CHOPs 2: Centering and Scaling", 
      "Rangeling CHOPs 3: Angular Velocity",
      "Rangeling CHOPs 4: Mouse Wheel",
      "Rangeling CHOPs 5: Merging and Null",
      "Input Data 2: Saved Data from TSV",
      "Rotation Vertex GLSL",
      "Perspective GLSL", 
      "2D Points to 2D Lines",
      "SDF Uneven Capsule",
      "Post Processing"
    ];

    // Tutorial State
    let currentSection = 0;
    let previousSection = 0;
    const totalSections = 15; // Hero + 14 tutorial sections
    let tutorialOpen = false;
    let cleanupTimeout = null;
    let stickyHotspots = new Set(); // Track sticky hotspots

    // Mobile detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Data loading state
    let dataLoaded = {
      tsv: false,
      rotationGLSL: false,
      perspectiveGLSL: false,
      lineDistanceGLSL: false
    };

    // Initialize Tesseract Shader instance
    let tesseractShader = null;

    // Load tutorial content from external file
    function loadTutorialContent() {
      return fetch('contentTesseract.html')
        .then(response => {
          if (!response.ok) {
            throw new Error(`Failed to load tutorial content: ${response.status}`);
          }
          return response.text();
        })
        .then(html => {
          document.getElementById('tutorialContainer').outerHTML = html;
          console.log('Tutorial content loaded successfully');
        })
        .catch(error => {
          console.error('Error loading tutorial content:', error);
          // Fallback: create a basic tutorial container
          document.getElementById('tutorialContainer').innerHTML = `
            <div class="tutorial-container" id="tutorialContainer">
              <div class="tutorial-header">
                <div class="tutorial-title">Tutorial Loading Error</div>
                <div class="tutorial-nav">
                  <button class="nav-btn close-btn" onclick="closeTutorial()">Ã—</button>
                </div>
              </div>
              <div class="tutorial-content">
                <div style="padding: 2rem; text-align: center;">
                  <p>Failed to load tutorial content. Please refresh the page and try again.</p>
                </div>
              </div>
            </div>
          `;
        });
    }

    // Load dynamic content
    function loadDynamicContent() {
      // TSV loader - load headers from file
      fetch('https://raw.githubusercontent.com/TrueFiasco/website/main/Tesseract%20Tutorial%20Pictures/code/euler%20cycle.tsv')
        .then(res => {
          if (!res.ok) throw new Error('Failed to load TSV');
          return res.text();
        })
        .then(tsv => {
          const rows = tsv.trim().split('\n');
          const headers = rows[0].split('\t');
          const dataRows = rows.slice(1);
          
          // Update table headers
          const thead = document.querySelector('#tsvTable thead tr');
          if (thead) {
            thead.innerHTML = '';
            headers.forEach(header => {
              const th = document.createElement('th');
              th.textContent = header.trim();
              thead.appendChild(th);
            });
            
            // Update table body
            const tbody = document.querySelector('#tsvTable tbody');
            if (tbody) {
              tbody.innerHTML = '';
              dataRows.forEach(row => {
                const cells = row.split('\t');
                const tr = document.createElement('tr');
                cells.forEach(cell => {
                  const td = document.createElement('td');
                  td.textContent = cell.trim();
                  tr.appendChild(td);
                });
                tbody.appendChild(tr);
              });
            }
          }
          dataLoaded.tsv = true;
        })
        .catch(err => {
          console.error('Failed to load TSV:', err);
          const tbody = document.querySelector('#tsvTable tbody');
          if (tbody) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #ff6b6b; font-style: italic;">Failed to load TSV data</td></tr>';
          }
        });

      // Code snippet loaders
      const codeSnippets = [
        {
          id: 'rotationGLSLContent',
          url: 'https://raw.githubusercontent.com/TrueFiasco/website/main/Tesseract%20Tutorial%20Pictures/code/vert_rotation_pixel.frag',
          key: 'rotationGLSL'
        },
        {
          id: 'perspectiveGLSLContent',
          url: 'https://raw.githubusercontent.com/TrueFiasco/website/main/Tesseract%20Tutorial%20Pictures/code/vert_persprective_pixel.frag',
          key: 'perspectiveGLSL'
        },
        {
          id: 'lineDistanceGLSLContent',
          url: 'https://raw.githubusercontent.com/TrueFiasco/website/main/Tesseract%20Tutorial%20Pictures/code/line_mindist_pixel.frag',
          key: 'lineDistanceGLSL'
        }
      ];

      codeSnippets.forEach(snippet => {
        fetch(snippet.url)
          .then(res => {
            if (!res.ok) throw new Error(`Failed to load ${snippet.key}`);
            return res.text();
          })
          .then(code => {
            const el = document.getElementById(snippet.id)?.querySelector('.code-content');
            if (el) {
              el.textContent = code;
              el.classList.remove('loading');
              dataLoaded[snippet.key] = true;
            }
          })
          .catch(err => {
            console.error(`Failed to load ${snippet.key}:`, err);
            const el = document.getElementById(snippet.id)?.querySelector('.code-content');
            if (el) {
              el.textContent = `Failed to load ${snippet.key} code`;
              el.classList.remove('loading');
              el.classList.add('error');
            }
          });
      });
    }
    function updateSectionPadding(sectionIndex) {
      const section = document.querySelector(`#tutorialScroller .tutorial-section:nth-child(${sectionIndex})`);
      if (!section) return;
      
      const config = sectionConfig[sectionIndex];
      const hasBackgroundImage = config && config.image;
      
      if (hasBackgroundImage) {
        section.classList.add('has-background-image');
      } else {
        section.classList.remove('has-background-image');
      }
    }

    // Image transition functions
    function transitionToSection(newSection) {
      if (newSection === currentSection) return;
      
      previousSection = currentSection;
      currentSection = newSection;
      
      // Update section title in header
      updateSectionTitle();
      
      // Handle section scroller
      updateTutorial();
      
      // Handle image transitions in static container
      if (currentSection > 0 && currentSection <= 14) {
        transitionStaticImage(currentSection, previousSection);
      }
    }

    function updateSectionTitle() {
      const titleElement = document.getElementById('currentSectionTitle');
      if (titleElement && currentSection >= 0 && currentSection < sectionTitles.length) {
        titleElement.textContent = sectionTitles[currentSection];
      }
    

    // Dynamic padding management
      if (isMobile) {
        // Ensure consistent spacing on mobile regardless of image
        section.style.paddingBottom = '1rem';
      }
    }

    function transitionStaticImage(newSection, oldSection) {
      const config = sectionConfig[newSection];
      if (!config) return;
    
      const imageContainer = document.getElementById('staticImageContainer');
      if (!imageContainer) return;
    
      // Update section padding
      updateSectionPadding(newSection);
    
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }

  const existingImages = imageContainer.querySelectorAll('.tutorial-image');
  const currentImage = existingImages.length > 0 ? existingImages[existingImages.length - 1] : null;
  
  const newImage = document.createElement('img');
  newImage.className = 'tutorial-image';
  newImage.style.aspectRatio = config.aspectRatio.replace(':', '/');
  newImage.src = config.image;

  // FIXED: USE IDENTICAL LOGIC FOR BOTH MOBILE AND DESKTOP
  if (config.offset.x === 0 && config.offset.y === 0) {
    // Fade in place - no sliding
    newImage.style.transform = 'translate(0, 0)';
    newImage.style.opacity = '0';
    newImage.style.zIndex = '10';
  } else {
    // Slide in from offset position
    const startX = config.offset.x * 100;
    const startY = config.offset.y * 100;
    newImage.style.transform = `translate(${startX}%, ${startY}%)`;
    newImage.style.opacity = '0';
    newImage.style.zIndex = '10';
  }

  if (currentImage) {
    currentImage.style.zIndex = '5';
  }

  imageContainer.appendChild(newImage);
  
  // CRITICAL: Wait for image to load before transitioning
  newImage.onload = function() {
    // Force container to match loaded image height
    if (isMobile) {
      const imageHeight = newImage.offsetHeight;
      imageContainer.style.height = `${imageHeight}px`;
    }
    
    updateHotspots(config.hotspots);

    setTimeout(() => {
      // IDENTICAL TRANSITION LOGIC FOR BOTH MOBILE AND DESKTOP
      newImage.style.opacity = '1';
      newImage.style.transform = 'translate(0, 0)';

      if (currentImage) {
        if (config.offset.x === 0 && config.offset.y === 0) {
          currentImage.style.opacity = '0';
        } else {
          const exitX = -config.offset.x * 100;
          const exitY = -config.offset.y * 100;
          currentImage.style.transform = `translate(${exitX}%, ${exitY}%)`;
          currentImage.style.opacity = '0';
        }
      }

      cleanupTimeout = setTimeout(() => {
        const allImages = imageContainer.querySelectorAll('.tutorial-image');
        allImages.forEach(img => {
          if (img !== newImage && img.parentNode === imageContainer) {
            imageContainer.removeChild(img);
          }
        });
        
        // Reset container height after cleanup on mobile
        if (isMobile) {
          imageContainer.style.height = 'auto';
        }
        
        cleanupTimeout = null;
      }, 850);
    }, 10);
  };
  
  // If image is already cached, trigger onload immediately
  if (newImage.complete) {
    newImage.onload();
  }
}


    function updateHotspots(hotspots) {
      const hotspotContainer = document.getElementById('hotspotContainer');
      if (!hotspotContainer) return;

      // Clear sticky hotspots and existing hotspots
      stickyHotspots.clear();
      hotspotContainer.innerHTML = '';

      // Don't show hotspots on mobile
      if (isMobile) return;

      hotspots.forEach((hotspot, index) => {
        const element = document.createElement('div');
        element.className = 'hotspot';
        element.style.top = hotspot.top;
        element.style.left = hotspot.left;
        element.style.pointerEvents = 'auto';
        element.dataset.hotspotId = index;
        
        element.onmouseenter = () => showParameterDialog(element, hotspot.type);
        element.onmouseleave = () => {
          if (!stickyHotspots.has(index)) {
            hideParameterDialog();
          }
        };
        element.onclick = () => {
          const hotspotId = parseInt(element.dataset.hotspotId);
          if (stickyHotspots.has(hotspotId)) {
            stickyHotspots.delete(hotspotId);
            element.classList.remove('sticky');
            hideParameterDialog();
          } else {
            stickyHotspots.add(hotspotId);
            element.classList.add('sticky');
            showParameterDialog(element, hotspot.type);
          }
        };
        
        hotspotContainer.appendChild(element);
      });
    }

    function updateTutorial() {
      const scroller = document.getElementById('tutorialScroller');
      const tutorialContainer = document.getElementById('tutorialContainer');
      const progressBar = document.getElementById('progressBar');
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      
      if (currentSection === 0) {
        // Hero section - show mobile button on mobile devices
        if (tutorialContainer) {
          tutorialContainer.classList.remove('active');
        }
        if (progressBar) {
          progressBar.style.display = 'none';
        }
        
        // Show mobile button only on mobile devices when on hero section
        if (mobileBtn && isMobile) {
          mobileBtn.style.display = 'block';
          mobileBtn.style.opacity = '1';
          mobileBtn.style.visibility = 'visible';
          mobileBtn.style.pointerEvents = 'auto';
        }
        
        tutorialOpen = false;
      } else {
        // Tutorial section - hide mobile button
        if (tutorialContainer) {
          tutorialContainer.classList.add('active');
        }
        if (progressBar) {
          progressBar.style.display = 'flex';
        }
        
        // Hide mobile button when tutorial is active
        if (mobileBtn) {
          mobileBtn.style.opacity = '0';
          mobileBtn.style.visibility = 'hidden';
          mobileBtn.style.pointerEvents = 'none';
          // Don't change display to maintain smooth transitions
        }
        
        tutorialOpen = true;
        if (scroller) {
          const offset = (currentSection - 1) * -100;
          scroller.style.transform = `translateX(${offset}vw)`;
        }
        
        // Update padding for current section
        updateSectionPadding(currentSection);
      }
      
      updateProgressBar();
    }

    // Navigation functions
      function openTutorial() {
        console.log('openTutorial called'); // Debug log
        if (cleanupTimeout) {
          clearTimeout(cleanupTimeout);
          cleanupTimeout = null;
        }
        
        // Immediately hide mobile button when tutorial starts
        const mobileBtn = document.getElementById('mobileTutorialBtn');
        if (mobileBtn) {
          mobileBtn.style.opacity = '0';
          mobileBtn.style.visibility = 'hidden';
          mobileBtn.style.pointerEvents = 'none';
        }
        
        transitionToSection(1);
        initProgressBar();
      }

    function closeTutorial() {
      if (cleanupTimeout) {
        clearTimeout(cleanupTimeout);
        cleanupTimeout = null;
      }
      
      // Show mobile button again when returning to hero (mobile only)
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      if (mobileBtn && isMobile) {
        mobileBtn.style.opacity = '1';
        mobileBtn.style.visibility = 'visible';
        mobileBtn.style.pointerEvents = 'auto';
      }
      
      transitionToSection(0);
    }

    function goToHero() {
      closeTutorial();
    }

    function goToTutorialsPage() {
      window.open('https://truefiasco.org/tutorials', '_blank');
    }

    function goToNextSection() {
      if (currentSection < 14) {
        transitionToSection(currentSection + 1);
      }
    }

    function goToPrevSection() {
      if (currentSection > 1) {
        transitionToSection(currentSection - 1);
      }
    }

    function downloadTesseractResources() {
      // Open GitHub repository in new tab
      window.open('https://github.com/TrueFiasco/TouchDesigner-Tesseract-Tutorial', '_blank');
    }

    function initProgressBar() {
      const progressBar = document.getElementById('progressBar');
      if (progressBar) {
        progressBar.innerHTML = '';
        
        for (let i = 1; i <= 14; i++) {
          const dot = document.createElement('div');
          dot.className = 'progress-dot';
          if (i === currentSection) dot.classList.add('active');
          dot.onclick = () => transitionToSection(i);
          progressBar.appendChild(dot);
        }
      }
    }

    function updateProgressBar() {
      const dots = document.querySelectorAll('.progress-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', (index + 1) === currentSection);
      });
    }

    // Enhanced parameter dialog functions with smart positioning
    function showParameterDialog(element, type) {
      const dialog = document.getElementById('parameterDialog');
      const title = document.getElementById('parameterTitle');
      const content = document.getElementById('parameterContent');
      
      if (!dialog || !title || !content) return;
      
      const parameterData = {
        'math1-params': { title: 'Math1 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/math1.png' },
        'mousein1-wheel': { title: 'MouseIn1 CHOP - Wheel Channel', image: 'Tesseract%20Tutorial%20Pictures/parameters/mousein1.png' },
        'select2-params': { title: 'Select2 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/select2.png' },
        'filter2-params': { title: 'Filter2 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/filter2.png' },
        'filter3-params': { title: 'Filter3 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/filter3.png' },
        'filter4-params': { title: 'Filter4 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/filter4.png' },
        'vert_rotation': { title: 'Vertex Rotation GLSL Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/vert_rotation.png' },
        'vert_perspective': { title: 'Vertex Perspective GLSL Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/vert_perspective.png' },
        'transform1': { title: 'Transform1 TOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/transform1.png' },
        'reorder1': { title: 'Reorder1 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/reorder1.png' },
        'line_mindist': { title: 'SDF Line Min Distance Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/line_mindist.png' },
        'limits-params': { title: 'Limits TOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/limits.png' },
        'ramp-params': { title: 'Ramp TOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/ramp.png' },
        'lookup-params': { title: 'Lookup TOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/lookup.png' },
        'select1-detailed': { title: 'Select1 CHOP - Channel Selection', image: 'Tesseract%20Tutorial%20Pictures/parameters/select1.png' },
        'math3-params': { title: 'Math3 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/math3.png' },
        'filter1-params': { title: 'Filter1 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/filter1.png' },
        'speed2-params': { title: 'Speed2 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/speed2.png' },
        'math2-params': { title: 'Math2 CHOP Parameters', image: 'Tesseract%20Tutorial%20Pictures/parameters/math2.png' },
        'speed3-params': { title: 'Speed3 CHOP Parameters', params: ['Integration method', 'Velocity to position', 'Frame rate: 60Hz'] }
      };
      
      const data = parameterData[type] || { title: 'Parameters', params: ['Custom parameters will be shown here'] };
      
      title.textContent = data.title;
      
      if (data.image) {
        content.innerHTML = `<img src="${data.image}" style="width: 100%; max-width: 525px; border-radius: 5px;" alt="${data.title}">`;
      } else if (data.params) {
        content.innerHTML = data.params.map(param => `<div class="parameter-item">${param}</div>`).join('');
      } else {
        content.innerHTML = '<div class="parameter-item">No parameters available</div>';
      }
      
      // Smart positioning logic to keep dialog within viewport bounds
      const rect = element.getBoundingClientRect();
      const dialogWidth = 600; // max-width from CSS
      const dialogHeight = 400; // estimated height
      const padding = 20; // minimum distance from screen edge
      
      let left = rect.left + 45; // default position
      let top = rect.top - 50;
      
      // Check right edge - if dialog would go off screen, position it to the left
      if (left + dialogWidth > window.innerWidth - padding) {
        left = rect.left - dialogWidth - 10; // Position to left of hotspot
      }
      
      // Check left edge - ensure it doesn't go off the left side
      if (left < padding) {
        left = padding;
      }
      
      // Check top edge - if dialog would go above screen, position it below
      if (top < padding) {
        top = rect.bottom + 10; // Position below hotspot
      }
      
      // Check bottom edge - if dialog would go below screen, reposition
      if (top + dialogHeight > window.innerHeight - padding) {
        top = window.innerHeight - dialogHeight - padding;
      }
      
      dialog.style.left = `${left}px`;
      dialog.style.top = `${top}px`;
      dialog.classList.add('active');
    }

    function hideParameterDialog() {
      const dialog = document.getElementById('parameterDialog');
      if (dialog) {
        dialog.classList.remove('active');
      }
      
      // Clear all sticky hotspots
      stickyHotspots.clear();
      document.querySelectorAll('.hotspot.sticky').forEach(hotspot => {
        hotspot.classList.remove('sticky');
      });
    }

    // Widget fullscreen functions
    function showTSVFullscreen() {
      const modal = document.getElementById('tsvFullscreen');
      const content = document.getElementById('tsvFullscreenContent');
      if (modal && content) {
        const tsvContent = document.getElementById('tsvContent');
        if (tsvContent) {
          content.innerHTML = tsvContent.innerHTML;
        }
        modal.classList.add('active');
      }
    }

    function closeTSVFullscreen() {
      const modal = document.getElementById('tsvFullscreen');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    function showRotationGLSLFullscreen() {
      const modal = document.getElementById('rotationGLSLFullscreen');
      const content = document.getElementById('rotationGLSLFullscreenContent');
      
      if (modal && content) {
        // Get the code content and ensure it's properly structured for scrolling
        const originalCodeContent = document.querySelector('#rotationGLSLContent .code-content');
        if (originalCodeContent) {
          const codeText = originalCodeContent.textContent;
          
          // Create properly structured content for fullscreen with explicit height
          content.innerHTML = `<div class="code-content" style="height: auto; overflow: visible; white-space: pre-wrap;">${codeText}</div>`;
        }
        modal.classList.add('active');
      }
    }

    function closeRotationGLSLFullscreen() {
      const modal = document.getElementById('rotationGLSLFullscreen');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    function showPerspectiveGLSLFullscreen() {
      const modal = document.getElementById('perspectiveGLSLFullscreen');
      const content = document.getElementById('perspectiveGLSLFullscreenContent');
      
      if (modal && content) {
        // Get the code content and ensure it's properly structured for scrolling
        const originalCodeContent = document.querySelector('#perspectiveGLSLContent .code-content');
        if (originalCodeContent) {
          const codeText = originalCodeContent.textContent;
          
          // Create properly structured content for fullscreen with explicit height
          content.innerHTML = `<div class="code-content" style="height: auto; overflow: visible; white-space: pre-wrap;">${codeText}</div>`;
        }
        modal.classList.add('active');
      }
    }

    function closePerspectiveGLSLFullscreen() {
      const modal = document.getElementById('perspectiveGLSLFullscreen');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    function showLineDistanceGLSLFullscreen() {
      const modal = document.getElementById('lineDistanceGLSLFullscreen');
      const content = document.getElementById('lineDistanceGLSLFullscreenContent');
      
      if (modal && content) {
        // Get the code content and ensure it's properly structured for scrolling
        const originalCodeContent = document.querySelector('#lineDistanceGLSLContent .code-content');
        if (originalCodeContent) {
          const codeText = originalCodeContent.textContent;
          
          // Create properly structured content for fullscreen with explicit height
          content.innerHTML = `<div class="code-content" style="height: auto; overflow: visible; white-space: pre-wrap;">${codeText}</div>`;
        }
        modal.classList.add('active');
      }
    }

    function closeLineDistanceGLSLFullscreen() {
      const modal = document.getElementById('lineDistanceGLSLFullscreen');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    // Copy notification helper
    function showCopyNotification() {
      const notification = document.getElementById('copyNotification');
      if (notification) {
        notification.classList.add('show');
        setTimeout(() => {
          notification.classList.remove('show');
        }, 2000);
      }
    }

    // Copy to clipboard functions
    function copyTSVToClipboard() {
      const table = document.getElementById('tsvTable');
      if (!table) return;
      
      let tsvText = '';
      
      // Add header row (dynamically loaded)
      const headerCells = table.getElementsByTagName('thead')[0]?.getElementsByTagName('th');
      if (headerCells) {
        const headers = [];
        for (let header of headerCells) {
          headers.push(header.textContent);
        }
        tsvText += headers.join('\t') + '\n';
      }
      
      // Add data rows
      const rows = table.getElementsByTagName('tbody')[0]?.getElementsByTagName('tr');
      if (rows) {
        for (let row of rows) {
          const cells = row.getElementsByTagName('td');
          const rowData = [];
          for (let cell of cells) {
            rowData.push(cell.textContent);
          }
          tsvText += rowData.join('\t') + '\n';
        }
      }
      
      navigator.clipboard.writeText(tsvText).then(() => {
        console.log('TSV data copied to clipboard');
        showCopyNotification();
      }).catch(err => {
        console.error('Failed to copy TSV data: ', err);
      });
    }

    function copyRotationGLSLToClipboard() {
      // Check if fullscreen is active, if so copy from fullscreen content
      const fullscreenModal = document.getElementById('rotationGLSLFullscreen');
      let codeContent;
      
      if (fullscreenModal && fullscreenModal.classList.contains('active')) {
        codeContent = document.querySelector('#rotationGLSLFullscreenContent .code-content');
      } else {
        codeContent = document.querySelector('#rotationGLSLContent .code-content');
      }
      
      if (codeContent) {
        const text = codeContent.textContent;
        
        navigator.clipboard.writeText(text).then(() => {
          console.log('Rotation GLSL code copied to clipboard');
          showCopyNotification();
        }).catch(err => {
          console.error('Failed to copy rotation GLSL code: ', err);
        });
      }
    }

    function copyPerspectiveGLSLToClipboard() {
      // Check if fullscreen is active, if so copy from fullscreen content
      const fullscreenModal = document.getElementById('perspectiveGLSLFullscreen');
      let codeContent;
      
      if (fullscreenModal && fullscreenModal.classList.contains('active')) {
        codeContent = document.querySelector('#perspectiveGLSLFullscreenContent .code-content');
      } else {
        codeContent = document.querySelector('#perspectiveGLSLContent .code-content');
      }
      
      if (codeContent) {
        const text = codeContent.textContent;
        
        navigator.clipboard.writeText(text).then(() => {
          console.log('Perspective GLSL code copied to clipboard');
          showCopyNotification();
        }).catch(err => {
          console.error('Failed to copy perspective GLSL code: ', err);
        });
      }
    }

    function copyLineDistanceGLSLToClipboard() {
      // Check if fullscreen is active, if so copy from fullscreen content
      const fullscreenModal = document.getElementById('lineDistanceGLSLFullscreen');
      let codeContent;
      
      if (fullscreenModal && fullscreenModal.classList.contains('active')) {
        codeContent = document.querySelector('#lineDistanceGLSLFullscreenContent .code-content');
      } else {
        codeContent = document.querySelector('#lineDistanceGLSLContent .code-content');
      }
      
      if (codeContent) {
        const text = codeContent.textContent;
        
        navigator.clipboard.writeText(text).then(() => {
          console.log('Line Distance GLSL code copied to clipboard');
          showCopyNotification();
        }).catch(err => {
          console.error('Failed to copy line distance GLSL code: ', err);
        });
      }
    }

    // Updated wheel event handling to allow scrolling in fullscreen modals
    function onWheel(event) {
      // Check if any fullscreen modal is open
      const anyModalOpen = document.querySelector('.widget-fullscreen.active');
      
      // If a modal is open, allow normal scrolling within the modal content
      if (anyModalOpen) {
        // Don't prevent default - allow normal scrolling
        return;
      }

      // If tutorial is open but no modal, handle section navigation
      if (tutorialOpen) {
        event.preventDefault();
        const delta = event.deltaY;
        
        if (delta > 0) {
          goToNextSection();
        } else {
          goToPrevSection();
        }
        return;
      }
      
      // If on hero page, the shader will handle wheel events for the hypercube
    }

    async function init() {
      try {
        // Load tutorial content first
        await loadTutorialContent();
        
        // Initialize Tesseract shader
        tesseractShader = new TesseractShader('hypercube-canvas', {
          onTutorialOpen: openTutorial,
          getTutorialState: () => tutorialOpen
        });
        
        await tesseractShader.init();
        
        loadDynamicContent(); // Load TSV and code snippets
        initProgressBar();
        updateSectionTitle();
        
        // Setup wheel event for tutorial navigation
        document.addEventListener('wheel', onWheel);
        
        console.log('Tutorial application initialized successfully');
      } catch (error) {
        console.error('Failed to initialize tutorial application:', error);
      }
    }
    
    // Ensure button works on mobile only, click anywhere works on desktop
    function setupHeroInteraction() {
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      console.log('Device detection:', isMobile ? 'MOBILE' : 'DESKTOP');
      
      const mobileBtn = document.getElementById('mobileTutorialBtn');
      
      if (isMobile) {
        // MOBILE: Show button and setup interaction
        if (mobileBtn) {
          // Initial state - visible on hero section only
          mobileBtn.style.display = 'block';
          mobileBtn.style.visibility = 'visible';
          mobileBtn.style.opacity = '1';
          mobileBtn.style.pointerEvents = 'auto';
          
          console.log('Mobile button container forced visible');
          
          const btn = mobileBtn.querySelector('.mobile-start-btn');
          console.log('Mobile button element found:', !!btn);
          
          if (btn) {
            // Make button fully interactive
            btn.style.pointerEvents = 'auto';
            btn.style.zIndex = '1000000';
            
            // Clear any existing event listeners
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            // Add all event types for maximum compatibility
            newBtn.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              console.log('âœ… Mobile button CLICKED - Opening tutorial!');
              openTutorial();
            }, { passive: false });
            
            newBtn.addEventListener('touchstart', function(e) {
              e.preventDefault();
              e.stopPropagation();
              console.log('ðŸ“± Mobile button TOUCH START');
              newBtn.style.background = 'rgba(0, 255, 255, 0.4)';
            }, { passive: false });
            
            newBtn.addEventListener('touchend', function(e) {
              e.preventDefault();
              e.stopPropagation();
              console.log('âœ… Mobile button TOUCH END - Opening tutorial!');
              newBtn.style.background = 'rgba(0, 255, 255, 0.15)';
              openTutorial();
            }, { passive: false });
            
            console.log('âœ… Mobile button events attached successfully');
          } else {
            console.error('âŒ Mobile button element (.mobile-start-btn) not found');
          }
        } else {
          console.error('âŒ Mobile button container (#mobileTutorialBtn) not found');
        }
      } else {
        // DESKTOP: Completely hide button
        if (mobileBtn) {
          mobileBtn.style.display = 'none';
          mobileBtn.style.visibility = 'hidden';
          mobileBtn.style.opacity = '0';
          mobileBtn.style.pointerEvents = 'none';
          console.log('ðŸ–¥ï¸ Desktop - Mobile button completely hidden');
        }
        
        console.log('ðŸ–¥ï¸ Desktop click anywhere enabled via shader');
      }
    }


    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        init();
        setupHeroInteraction();
      });
    } else {
      init();
      setupHeroInteraction();
    }

    // Close modals with escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeTSVFullscreen();
        closeRotationGLSLFullscreen();
        closePerspectiveGLSLFullscreen();
        closeLineDistanceGLSLFullscreen();
        hideParameterDialog();
      }
    });
  </script>
</body>
</html>
