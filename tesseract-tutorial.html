<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tesseract Tutorial - Interactive TouchDesigner Guide</title>
  <style>
    @font-face {
      font-family: 'Spy Agency';
      src: url('./fonts/spyagencycond.ttf') format('truetype');
      font-weight: normal;
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Orbitron';
      src: url('./fonts/Orbitron-Regular.ttf') format('truetype');
      font-weight: 400;
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Orbitron';
      src: url('./fonts/Orbitron-Medium.ttf') format('truetype');
      font-weight: 500;
      font-display: swap;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a0a;
      color: #ffffff;
      overflow-x: hidden;
    }

    /* Hero Section with Hypercube */
    .hero-section {
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
      cursor: pointer;
      transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      position: relative;
      overflow: hidden;
    }

    .hero-section:hover {
      transform: scale(1.02);
    }

    .hero-content {
      text-align: center;
      z-index: 2;
    }

    .hero-title {
      font-family: 'Spy Agency', 'Arial', sans-serif;
      font-size: clamp(3.75rem, 12vw, 9rem);
      font-weight: normal;
      margin-bottom: 1rem;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientShift 3s ease-in-out infinite;
    }

    .hero-subtitle {
      font-family: 'Orbitron', 'Arial', sans-serif;
      font-size: 2.25rem;
      margin-bottom: 2rem;
      opacity: 0.9;
      line-height: 1.2;
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .hypercube-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* Tutorial Container */
    .tutorial-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      z-index: 1000;
      transform: translateY(100%);
      transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      display: flex;
      flex-direction: column;
    }

    .tutorial-container.active {
      transform: translateY(0);
    }

    /* Tutorial Header */
    .tutorial-header {
      background: #1a1a2e;
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .tutorial-nav {
      display: flex;
      gap: 1rem;
    }

    .nav-btn {
      background: #333;
      border: none;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .nav-btn:hover {
      background: #555;
    }

    .close-btn {
      background: #ff4757;
      font-size: 1.5rem;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Tutorial Content */
    .tutorial-content {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    .tutorial-scroller {
      display: flex;
      height: 100%;
      transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      will-change: transform;
    }

    .tutorial-section {
      min-width: 100vw;
      height: 100%;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    /* Section-specific gradients */
    .tutorial-section:nth-child(1) { background: linear-gradient(180deg, #1a1a2e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(2) { background: linear-gradient(180deg, #16213e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(3) { background: linear-gradient(180deg, #1a1a2e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(4) { background: linear-gradient(180deg, #16213e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(5) { background: linear-gradient(180deg, #1a1a2e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(6) { background: linear-gradient(180deg, #16213e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(7) { background: linear-gradient(180deg, #1a1a2e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(8) { background: linear-gradient(180deg, #16213e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(9) { background: linear-gradient(180deg, #1a1a2e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(10) { background: linear-gradient(180deg, #16213e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(11) { background: linear-gradient(180deg, #1a1a2e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(12) { background: linear-gradient(180deg, #16213e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(13) { background: linear-gradient(180deg, #1a1a2e 0%, #191b1f 50%, #191b1f 100%); }
    .tutorial-section:nth-child(14) { background: linear-gradient(180deg, #16213e 0%, #191b1f 50%, #191b1f 100%); }

    .section-content {
      flex: 1;
      overflow-y: auto;
      padding-bottom: 2rem;
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .section-content.with-screenshot {
      flex: 0 1 auto;
      max-height: 60%;
    }

    /* Static image container that holds transitions */
    .section-visual {
      flex: 0 0 300px;
      background: #222;
      border-radius: 10px;
      position: relative;
      overflow: hidden;
      margin-top: auto;
    }

    .section-visual.full-width {
      flex: 1;
      min-height: 400px;
    }

    /* Image transition container - STATIC positioning */
    .image-transition-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .tutorial-image {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 10px;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .tutorial-image.active {
      opacity: 1;
      transform: translateX(0);
    }

    .tutorial-image.previous {
      opacity: 0;
      transform: translateX(-100%);
    }

    /* Special layout for section 1 */
    .section-1-layout {
      display: flex;
      gap: 2rem;
      height: 60%;
    }

    .section-1-left {
      flex: 2;
      display: flex;
      flex-direction: column;
    }

    .section-1-right {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    /* Hotspot System */
    .hotspot {
      position: absolute;
      width: 20px;
      height: 20px;
      background: #00ffff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
      animation: pulse 2s infinite;
      border: 2px solid rgba(255, 255, 255, 0.3);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      z-index: 50;
      pointer-events: auto;
    }

    .hotspot:hover {
      transform: scale(1.3);
      background: #ff00ff;
      box-shadow: 0 0 25px rgba(255, 0, 255, 0.8);
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
    }

    .parameter-dialog {
      position: fixed;
      background: #1a1a2e;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 1rem;
      max-width: 400px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.8);
      z-index: 1000;
      display: none;
      pointer-events: none;
    }

    .parameter-dialog.active {
      display: block;
    }

    .parameter-dialog img {
      width: 100%;
      max-width: 350px;
      border-radius: 5px;
      margin-top: 0.5rem;
    }

    .parameter-item {
      margin: 0.5rem 0;
      padding: 0.3rem;
      background: #333;
      border-radius: 3px;
      font-family: monospace;
      font-size: 0.9rem;
    }

    /* Code Snippet Modal */
    .code-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }

    .code-modal.active {
      display: flex;
    }

    .code-content {
      background: #1a1a2e;
      padding: 2rem;
      border-radius: 10px;
      max-width: 80%;
      max-height: 80%;
      overflow: auto;
    }

    .code-block {
      background: #0d1117;
      padding: 1rem;
      border-radius: 5px;
      margin: 1rem 0;
      overflow-x: auto;
    }

    .code-block pre {
      color: #c9d1d9;
      font-family: 'Courier New', monospace;
      margin: 0;
    }

    /* Action Buttons */
    .action-buttons {
      display: flex;
      gap: 1rem;
      margin: 1rem 0;
    }

    .action-btn {
      background: linear-gradient(45deg, #00ffff, #0080ff);
      border: none;
      color: white;
      padding: 0.7rem 1.5rem;
      border-radius: 25px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 128, 255, 0.4);
    }

    /* Progress Indicator */
    .progress-bar {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 0.5rem;
      z-index: 100;
    }

    .progress-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #333;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .progress-dot.active {
      background: #00ffff;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }

    /* Typography */
    h1 { font-size: 2.5rem; margin-bottom: 1rem; color: #00ffff; }
    h2 { font-size: 2rem; margin-bottom: 0.8rem; color: #ff6b6b; }
    h3 { font-size: 1.5rem; margin-bottom: 0.6rem; color: #4ecdc4; }
    
    p { line-height: 1.6; margin-bottom: 1rem; }
    
    .highlight {
      background: rgba(255, 255, 0, 0.2);
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
    }

    .tip {
      background: #2c3e50;
      border-left: 4px solid #3498db;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 0 5px 5px 0;
    }

    @media (max-width: 768px) {
      .tutorial-section {
        flex-direction: column;
        padding: 1rem;
      }
      
      .hero-title {
        font-size: 2.5rem;
      }
      
      .hero-subtitle {
        font-size: 1.2rem;
      }

      .section-1-layout {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <!-- Hero Section with Hypercube -->
  <div class="hero-section">
    <canvas class="hypercube-canvas" id="hypercube-canvas"></canvas>
    <button class="nav-btn close-btn" onclick="window.history.back()" style="position: absolute; top: 2rem; right: 2rem; z-index: 100;">×</button>
    <div class="hero-content" style="opacity: 0; pointer-events: none;">
      <h1 class="hero-title">TESSERACT</h1>
      <p class="hero-subtitle">TouchDesigner Tutorial using GLSL<br>click to start</p>
    </div>
  </div>

  <!-- Tutorial Container -->
  <div class="tutorial-container" id="tutorialContainer">
    <!-- Tutorial Header -->
    <div class="tutorial-header">
      <div class="tutorial-nav">
        <span style="color: #ccc; font-size: 0.9rem;">Use scroll wheel to navigate</span>
      </div>
      <button class="nav-btn close-btn" onclick="closeTutorial()">×</button>
    </div>

    <!-- Tutorial Content -->
    <div class="tutorial-content">
      <div class="tutorial-scroller" id="tutorialScroller">
        
        <!-- Section 1: Overview -->
        <div class="tutorial-section">
          <div class="section-1-layout">
            <div class="section-1-left">
              <h1>TESSERACT Overview</h1>
              <div class="tip">
                <strong>Pro Tip:</strong> Understanding 4D rotations requires thinking beyond our 3D intuition. We'll break this down step by step!
              </div>
              
              <h3>What We'll Cover:</h3>
              <ul style="margin-left: 2rem; line-height: 1.8;">
                <li><strong>CHOP Networks:</strong> Mouse input processing and rotation control</li>
                <li><strong>4D Mathematics:</strong> Rotation matrices and perspective projection</li>
                <li><strong>GLSL Shaders:</strong> Vertex transformation and SDF rendering</li>
                <li><strong>Interactive Controls:</strong> Real-time parameter manipulation</li>
              </ul>
            </div>
            
            <div class="section-1-right">
              <h3>Key Resources:</h3>
              <p>This tutorial references concepts from:</p>
              <ul style="margin-left: 2rem; line-height: 1.8;">
                <li><a href="https://en.wikipedia.org/wiki/Tesseract" style="color: #00ffff;">Tesseract mathematics</a></li>
                <li><a href="https://hollasch.github.io/ray4/Four-Space_Visualization_of_4D_Objects.html" style="color: #00ffff;">4D projection techniques</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Rotation_matrix#In_four_dimensions" style="color: #00ffff;">4D rotation matrices</a></li>
                <li><a href="https://iquilezles.org/articles/distfunctions2d/" style="color: #00ffff;">Inigo Quilez's SDF functions</a></li>
                <li><a href="https://docs.derivative.ca/GLSL_TOP" style="color: #00ffff;">Writing GLSL TOPs in TouchDesigner</a></li>
              </ul>

              <div class="action-buttons">
                <button class="action-btn" onclick="downloadProjectFiles()">Download Project Files</button>
              </div>
            </div>
          </div>
          
          <div class="section-visual full-width">
            <div class="image-transition-container">
              <img class="tutorial-image active" 
                   src="Tesseract%20Tutorial%20Pictures/Network%20images/network_overview.png" 
                   alt="Network Overview" 
                   style="aspect-ratio: 3615/1097;">
            </div>
          </div>
        </div>

        <!-- Section 2: The CHOP Network -->
        <div class="tutorial-section">
          <div class="section-content with-screenshot">
            <h1>The CHOP Network</h1>
            <p>Our CHOP network processes mouse input to control the hypercube rotation. We can use any input device to control any axis or parameter - the flexibility of TouchDesigner shines here.</p>
            
            <div style="display: flex; gap: 4rem; margin: 2rem 0;">
              <div>
                <h3>Input Sources:</h3>
                <p>We take mouse position from either <span class="highlight">mousein</span> or <span class="highlight">panel</span> CHOPs, and scroll increment from mousein to control our hypercube rotation.</p>
              </div>
              <div>
                <h3>Network Flow:</h3>
                <p>The network processes raw input → applies velocity calculations → converts to angular position → feeds rotation matrices.</p>
              </div>
            </div>
          </div>
          
          <div class="section-visual full-width">
            <div class="image-transition-container">
              <img class="tutorial-image active" 
                   src="Tesseract%20Tutorial%20Pictures/Network%20images/chop_network.png" 
                   alt="CHOP Network" 
                   style="aspect-ratio: 1852/571;">
            </div>
          </div>
        </div>

        <!-- Section 3: Input Data 1 -->
        <div class="tutorial-section">
          <div class="section-content with-screenshot">
            <h1>Input Data 1: Mouse UV Control</h1>
            <p>Using panel CHOP to get mouse UV coordinates, selecting <span class="highlight">rollu</span> and <span class="highlight">rollv</span> or <span class="highlight">tx ty</span> from mousein to control the Y and X axis respectively.</p>

            <h3>Key CHOPs:</h3>
            <ul style="margin-left: 2rem; line-height: 1.8;">
              <li><strong>panel1:</strong> Captures mouse UV coordinates</li>
              <li><strong>mousein1:</strong> Raw mouse input data</li>
              <li><strong>select1:</strong> Filters specific channels</li>
            </ul>

            <div class="tip">
              <strong>Remember:</strong> UV coordinates give us normalized 0-1 values, perfect for controlling rotations!
            </div>
          </div>

          <div class="section-visual full-width">
            <div class="image-transition-container">
              <img class="tutorial-image active" 
                   src="Tesseract%20Tutorial%20Pictures/Network%20images/mouse_uv_control.png" 
                   alt="Input Processing CHOPs" 
                   style="aspect-ratio: 1852/571;">
              <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                <div class="hotspot" style="top: 35%; left: 17%; pointer-events: auto;" 
                     onmouseenter="showParameterDialog(this, 'select1-detailed')"
                     onmouseleave="hideParameterDialog()"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Continue with remaining sections... -->
        <!-- I'll show the pattern for a few more sections -->

        <!-- Section 4: Rangeling CHOPs 1 -->
        <div class="tutorial-section">
          <div class="section-content with-screenshot">
            <h1>Rangeling CHOPs 1: Mouse Velocity</h1>
            <p>I increase the responsive part of the interaction, which is driven by mouse velocity. We use a <span class="highlight">slope</span> CHOP to get velocity and a <span class="highlight">filter</span> to give this a more natural feel when you stop moving the mouse.</p>

            <h3>Processing Chain:</h3>
            <ul style="margin-left: 2rem; line-height: 1.8;">
              <li><strong>math3:</strong> Mathematical operations on input</li>
              <li><strong>slope1:</strong> Calculates velocity from position changes</li>
              <li><strong>filter1:</strong> Smooths the velocity for natural feel</li>
            </ul>

            <div class="tip">
              <strong>Pro Tip:</strong> Velocity-based interaction feels more intuitive than direct position mapping!
            </div>
          </div>

          <div class="section-visual full-width">
            <div class="image-transition-container">
              <img class="tutorial-image active" 
                   src="Tesseract%20Tutorial%20Pictures/Network%20images/mouse_velocity.png" 
                   alt="Velocity Processing CHOPs" 
                   style="aspect-ratio: 1852/571;">
              <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                <div class="hotspot" style="top: 4%; left: 29%; pointer-events: auto;" 
                     onmouseenter="showParameterDialog(this, 'math3-params')"
                     onmouseleave="hideParameterDialog()"></div>
                <div class="hotspot" style="top: 4%; left: 52%; pointer-events: auto;" 
                     onmouseenter="showParameterDialog(this, 'filter1-params')"
                     onmouseleave="hideParameterDialog()"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Add remaining sections 5-14 following the same pattern -->
        <!-- Each section will have its configured aspect ratio and transition offset -->

      </div>
    </div>

    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>
  </div>

  <!-- Parameter Dialog -->
  <div class="parameter-dialog" id="parameterDialog">
    <h4 id="parameterTitle">Parameters</h4>
    <div id="parameterContent"></div>
  </div>

  <!-- Code Modal -->
  <div class="code-modal" id="codeModal">
    <div class="code-content">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h3 id="codeTitle">Code Snippet</h3>
        <button class="nav-btn" onclick="closeCodeModal()">×</button>
      </div>
      <div id="codeContent"></div>
    </div>
  </div>

  <!-- Three.js for Hypercube -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // Tutorial Section Configuration
    const sectionConfig = {
      1: { 
        aspectRatio: "3615:1097", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/network_overview.png"
      },
      2: { 
        aspectRatio: "1852:571", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/chop_network.png"
      },
      3: { aspectRatio: "1852:571", offset: {x: 0, y: 0} },
      4: { aspectRatio: "1852:571", offset: {x: 0, y: 0} },
      5: { aspectRatio: "1852:571", offset: {x: 0, y: 0} },
      6: { aspectRatio: "1852:571", offset: {x: 0, y: 0} },
      7: { aspectRatio: "1852:571", offset: {x: 0, y: 0} },
      8: { aspectRatio: "1852:571", offset: {x: 0, y: 0} },
      9: { 
        aspectRatio: "1456:478", 
        offset: {x: 1.0, y: 0},
        image: "Tesseract%20Tutorial%20Pictures/Network%20images/euler_in.png"
      },
      10: { aspectRatio: "1920:571", offset: {x: 1.0, y: 0} },
      11: { aspectRatio: "1920:571", offset: {x: 0, y: 0} },
      12: { aspectRatio: "1920:571", offset: {x: 0, y: 0} },
      13: { aspectRatio: "1920:571", offset: {x: 1.0, y: 0} }
    };

    // Tutorial State
    let currentSection = 0;
    let previousSection = 0;
    const totalSections = 15;
    let tutorialOpen = false;

    // Hypercube variables
    let scene, camera, renderer, uniforms;
    let mousePos = { x: 0, y: 0 };
    let normalizedMouse = { x: 0, y: 0 };
    let velocity = { x: 0, y: 0 };
    let slowVelocity = { x: 0, y: 0 };
    let angles = { rx: 0, ry: 0, rw: 0 };
    let wheelVelocity = 0;
    const maxSlowVelocity = 0.25;

    // Image transition functions
    function transitionToSection(newSection) {
      if (newSection === currentSection) return;
      
      previousSection = currentSection;
      currentSection = newSection;
      
      // Handle section scroller
      updateTutorial();
      
      // Handle image transitions
      if (currentSection > 0 && currentSection <= 13) {
        transitionSectionImage(currentSection, previousSection);
      }
    }

    function transitionSectionImage(newSection, oldSection) {
      const config = sectionConfig[newSection];
      if (!config) return;

      const sectionElement = document.querySelector(`.tutorial-section:nth-child(${newSection})`);
      if (!sectionElement) return;

      const imageContainer = sectionElement.querySelector('.image-transition-container');
      if (!imageContainer) return;

      const currentImage = imageContainer.querySelector('.tutorial-image.active');
      
      // Create new image element
      const newImage = document.createElement('img');
      newImage.className = 'tutorial-image';
      newImage.style.aspectRatio = config.aspectRatio.replace(':', '/');
      
      // Set image source
      if (config.image) {
        newImage.src = config.image;
      } else {
        // Use existing image from current section
        const existingImg = sectionElement.querySelector('img[src*="Tesseract"]');
        if (existingImg) {
          newImage.src = existingImg.src;
        }
      }

      // Set initial position based on offset
      if (config.offset.x === 0 && config.offset.y === 0) {
        // Fade only transition
        newImage.style.transform = `translateX(0)`;
        newImage.style.opacity = '0';
      } else {
        // Translate + fade transition
        const offsetX = config.offset.x * 100;
        const offsetY = config.offset.y * 100;
        newImage.style.transform = `translate(${offsetX}%, ${offsetY}%)`;
        newImage.style.opacity = '0';
      }

      // Add new image to container
      imageContainer.appendChild(newImage);

      // Trigger transition
      requestAnimationFrame(() => {
        // Animate new image in
        newImage.style.opacity = '1';
        newImage.style.transform = 'translate(0, 0)';
        newImage.classList.add('active');

        // Animate old image out (if exists)
        if (currentImage) {
          if (config.offset.x === 0 && config.offset.y === 0) {
            // Fade out only
            currentImage.style.opacity = '0';
          } else {
            // Translate and fade out
            const offsetX = -config.offset.x * 100;
            const offsetY = -config.offset.y * 100;
            currentImage.style.transform = `translate(${offsetX}%, ${offsetY}%)`;
            currentImage.style.opacity = '0';
          }
          currentImage.classList.remove('active');
          currentImage.classList.add('previous');

          // Remove old image after transition
          setTimeout(() => {
            if (currentImage.parentNode) {
              currentImage.parentNode.removeChild(currentImage);
            }
          }, 800);
        }
      });
    }

    // Initialize hypercube (same as before)
    async function initHypercube() {
      const canvas = document.getElementById('hypercube-canvas');
      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      
      renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Create vertex texture (33 points Euler cycle)
      const vertexData = new Float32Array(33 * 4);
      const vertices = [
        [0,0,0,0], [0,0,0,1], [1,0,0,1], [1,1,0,1], [0,1,0,1], [0,0,0,1], [0,0,1,1], [0,1,1,1],
        [0,1,0,1], [0,1,0,0], [0,1,1,0], [0,1,1,1], [1,1,1,1], [1,1,1,0], [1,1,0,0], [1,1,0,1],
        [1,1,1,1], [1,0,1,1], [1,0,1,0], [1,0,0,0], [1,0,0,1], [1,0,1,1], [0,0,1,1], [0,0,1,0],
        [1,0,1,0], [1,1,1,0], [0,1,1,0], [0,0,1,0], [0,0,0,0], [1,0,0,0], [1,1,0,0], [0,1,0,0],
        [0,0,0,0]
      ];
      
      vertices.forEach((vertex, i) => {
        vertexData[i * 4] = (vertex[0] - 0.5) * 2;
        vertexData[i * 4 + 1] = (vertex[1] - 0.5) * 2;
        vertexData[i * 4 + 2] = (vertex[2] - 0.5) * 2;
        vertexData[i * 4 + 3] = (vertex[3] - 0.5) * 2;
      });
      
      const vertexTexture = new THREE.DataTexture(
        vertexData, 33, 1, THREE.RGBAFormat, THREE.FloatType
      );
      vertexTexture.needsUpdate = true;
      
      // Create text texture
      const textTexture = await createTesseractTextTexture();
      
      // Fragment shader (same as before)
      const fragmentShader = `
        uniform float u_time;
        uniform vec2 u_resolution;
        uniform sampler2D u_vertices;
        uniform sampler2D u_textTexture;
        uniform vec3 u_rotation;
        uniform float u_lineWidth;
        uniform float u_fov;
        uniform float u_perspective;
        uniform float u_cameraZ;
        
        mat4 rotateX(float angle) {
          float c = cos(angle); float s = sin(angle);
          return mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0);
        }
        
        mat4 rotateY(float angle) {
          float c = cos(angle); float s = sin(angle);
          return mat4(c, 0.0, s, 0.0, 0.0, 1.0, 0.0, 0.0, -s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0);
        }
        
        mat4 rotateWY(float angle) {
          float c = cos(angle); float s = sin(angle);
          return mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c);
        }
        
        float distanceToLineSegment(vec2 p, vec2 a, vec2 b) {
          vec2 pa = p - a; vec2 ba = b - a;
          float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
          return length(pa - ba * h);
        }
        
        vec2 project4DTo2D(vec4 point4D) {
          vec3 pos3D = point4D.xyz * (point4D.w + u_perspective);
          vec3 camPos = vec3(0.0, 0.0, u_cameraZ);
          vec3 relPos = pos3D - camPos;
          float f = 1.0 / tan(radians(u_fov) * 0.5);
          vec2 projected = vec2(f * relPos.x / relPos.z, f * relPos.y / relPos.z);
          return projected * 0.1;
        }
        
        void main() {
          vec2 st = gl_FragCoord.xy / u_resolution.xy;
          vec2 screenSt = st;
          st = (st - 0.5) * 2.0;
          st.x *= u_resolution.x / u_resolution.y;
          
          vec4 textSample = texture2D(u_textTexture, screenSt);
          float textMask = textSample.r;
          
          mat4 rotation = rotateWY(u_rotation.z) * rotateY(u_rotation.y) * rotateX(u_rotation.x);
          
          float minDist = 1000.0;
          
          for (int i = 0; i < 32; i++) {
            vec4 vertex1 = texture2D(u_vertices, vec2((float(i) + 0.5) / 33.0, 0.5));
            vec4 vertex2 = texture2D(u_vertices, vec2((float(i + 1) + 0.5) / 33.0, 0.5));
            
            vertex1 = rotation * vertex1;
            vertex2 = rotation * vertex2;
            
            vec2 p1 = project4DTo2D(vertex1);
            vec2 p2 = project4DTo2D(vertex2);
            
            float dist = distanceToLineSegment(st, p1, p2);
            minDist = min(minDist, dist);
          }
          
          float intensity = smoothstep(0.0, u_lineWidth, minDist);
          
          vec3 lineColor = vec3(0.2, 0.8, 1.0);
          vec3 glowColor = vec3(0.6, 0.3, 1.0);
          vec3 bgColor = vec3(0.05, 0.05, 0.15);
          
          vec3 color = mix(lineColor, bgColor, intensity);
          float glow = exp(-minDist * 30.0) * 0.5;
          color += glow * glowColor;
          
          if (textMask > 0.1) {
            float textGlow = exp(-minDist * 20.0) * 2.0;
            vec3 textGlowColor = vec3(1.0, 0.8, 0.2);
            color += textGlow * textGlowColor * textMask;
            
            if (minDist < u_lineWidth * 2.0) {
              vec3 textLineColor = vec3(1.0, 0.9, 0.3);
              float textInfluence = (1.0 - minDist / (u_lineWidth * 2.0)) * textMask;
              color = mix(color, textLineColor, textInfluence * 0.7);
            }
            
            float sparkleFreq = 15.0;
            float sparkle = sin(st.x * sparkleFreq + u_time * 3.0) * sin(st.y * sparkleFreq + u_time * 2.5);
            sparkle = pow(max(sparkle, 0.0), 3.0);
            color += sparkle * 0.3 * textMask * vec3(1.0, 0.8, 0.4);
          }
          
          float pulse = sin(u_time * 2.0) * 0.5 + 0.5;
          if (minDist < u_lineWidth * 0.5) {
            float pulseMult = textMask > 0.1 ? 0.6 : 0.3;
            color = mix(color, vec3(1.0), pulse * pulseMult);
          }
          
          float sparkle = sin(st.x * 20.0 + u_time) * sin(st.y * 20.0 + u_time * 1.1);
          color += sparkle * 0.05 * (1.0 - intensity) * (1.0 - textMask);
          
          gl_FragColor = vec4(color, 0.8);
        }
      `;

      const vertexShader = `void main() { gl_Position = vec4(position, 1.0); }`;

      uniforms = {
        u_time: { value: 0.0 },
        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        u_vertices: { value: vertexTexture },
        u_textTexture: { value: textTexture },
        u_rotation: { value: new THREE.Vector3(0, 0, 0) },
        u_lineWidth: { value: 0.02 },
        u_fov: { value: 7.0 },
        u_perspective: { value: 2.3 },
        u_cameraZ: { value: 10.0 }
      };

      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true
      });

      const plane = new THREE.PlaneGeometry(2, 2);
      const mesh = new THREE.Mesh(plane, material);
      scene.add(mesh);
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('wheel', onWheel);
      canvas.addEventListener('click', openTutorial);
      canvas.style.cursor = 'pointer';
    }

    // Create text texture for TESSERACT
    async function createTesseractTextTexture() {
      await waitForFonts();
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      const baseFontSize = Math.min(window.innerWidth * 0.12, 144);
      const subtitleFontSize = Math.min(window.innerWidth * 0.036, 36);
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      ctx.font = `${baseFontSize}px "Spy Agency"`;
      const titleY = centerY - 30;
      ctx.fillText('TESSERACT', centerX, titleY);
      
      ctx.font = `400 ${subtitleFontSize}px Orbitron`;
      const subtitleLine1 = 'TouchDesigner Tutorial using GLSL';
      const subtitleLine2 = 'click to start';
      const subtitleY = titleY + baseFontSize * 0.8 + 20;
      const lineSpacing = subtitleFontSize * 1.2;
      
      ctx.fillText(subtitleLine1, centerX, subtitleY);
      ctx.fillText(subtitleLine2, centerX, subtitleY + lineSpacing);
      
      return new THREE.CanvasTexture(canvas);
    }

    async function waitForFonts() {
      return new Promise((resolve) => {
        const testCanvas = document.createElement('canvas');
        const testCtx = testCanvas.getContext('2d');
        
        function checkFonts() {
          testCtx.font = '48px "Spy Agency", serif';
          const spyAgencyWidth = testCtx.measureText('TESSERACT').width;
          testCtx.font = '48px serif';
          const serifWidth = testCtx.measureText('TESSERACT').width;
          
          if (Math.abs(spyAgencyWidth - serifWidth) > 1) {
            resolve();
          } else {
            setTimeout(checkFonts, 100);
          }
        }
        checkFonts();
        setTimeout(resolve, 5000);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      
      uniforms.u_time.value += 0.016;
      
      uniforms.u_rotation.value.x = angles.rx;
      uniforms.u_rotation.value.y = angles.ry;
      uniforms.u_rotation.value.z = angles.rw;
      
      angles.rx += velocity.x + slowVelocity.x;
      angles.ry += velocity.y + slowVelocity.y;
      angles.rw += wheelVelocity;
      
      velocity.x *= 0.95;
      velocity.y *= 0.95;
      wheelVelocity *= 0.96;
      
      const targetSlowVelX = normalizedMouse.y * 0.0125;
      const targetSlowVelY = normalizedMouse.x * 0.0125;
      
      slowVelocity.x += (targetSlowVelX - slowVelocity.x) * 0.1;
      slowVelocity.y += (targetSlowVelY - slowVelocity.y) * 0.1;
      
      const slowSpeed = Math.sqrt(slowVelocity.x * slowVelocity.x + slowVelocity.y * slowVelocity.y);
      if (slowSpeed > maxSlowVelocity) {
        slowVelocity.x = (slowVelocity.x / slowSpeed) * maxSlowVelocity;
        slowVelocity.y = (slowVelocity.y / slowSpeed) * maxSlowVelocity;
      }
      
      renderer.render(scene, camera);
    }

    function onMouseMove(event) {
      if (tutorialOpen) return;
      
      const newMousePos = {
        x: event.clientX / window.innerWidth,
        y: event.clientY / window.innerHeight
      };
      
      const deltaX = (newMousePos.x - mousePos.x) * 2.0;
      const deltaY = (newMousePos.y - mousePos.y) * 2.0;
      
      velocity.x += deltaY * 0.15;
      velocity.y += deltaX * 0.15;
      
      mousePos = newMousePos;
      
      normalizedMouse.x = (mousePos.x - 0.5) * 2;
      normalizedMouse.y = (mousePos.y - 0.5) * 2;
    }

    function onWheel(event) {
      if (tutorialOpen) {
        event.preventDefault();
        const delta = event.deltaY;
        
        if (delta > 0) {
          transitionToSection((currentSection + 1) % totalSections);
        } else {
          transitionToSection((currentSection - 1 + totalSections) % totalSections);
        }
        return;
      }
      
      const wheelDelta = event.deltaY > 0 ? 0.5 : -0.5;
      wheelVelocity += wheelDelta * 0.07;
    }

    function updateTutorial() {
      const scroller = document.getElementById('tutorialScroller');
      const tutorialContainer = document.getElementById('tutorialContainer');
      const progressBar = document.getElementById('progressBar');
      
      if (currentSection === 0) {
        tutorialContainer.classList.remove('active');
        progressBar.style.display = 'none';
        tutorialOpen = false;
      } else {
        tutorialContainer.classList.add('active');
        progressBar.style.display = 'flex';
        tutorialOpen = true;
        const offset = (currentSection - 1) * -100;
        scroller.style.transform = `translateX(${offset}vw)`;
      }
      
      updateProgressBar();
    }

    function openTutorial() {
      transitionToSection(1);
      initProgressBar();
    }

    function closeTutorial() {
      transitionToSection(0);
    }

    function initProgressBar() {
      const progressBar = document.getElementById('progressBar');
      progressBar.innerHTML = '';
      
      for (let i = 1; i <= 13; i++) {
        const dot = document.createElement('div');
        dot.className = 'progress-dot';
        if (i === currentSection) dot.classList.add('active');
        dot.onclick = () => transitionToSection(i);
        progressBar.appendChild(dot);
      }
    }

    function updateProgressBar() {
      const dots = document.querySelectorAll('.progress-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', (index + 1) === currentSection);
      });
    }

    // Parameter dialog and other functions remain the same...
    function showParameterDialog(element, type) {
      // Same implementation as before
    }

    function hideParameterDialog() {
      const dialog = document.getElementById('parameterDialog');
      dialog.classList.remove('active');
    }

    function showCode(type) {
      // Same implementation as before
    }

    function closeCodeModal() {
      document.getElementById('codeModal').classList.remove('active');
    }

    function downloadProjectFiles() {
      // Same implementation as before
    }

    function onWindowResize() {
      if (camera && renderer && uniforms) {
        renderer.setSize(window.innerWidth, window.innerHeight);
        uniforms.u_resolution.value.x = window.innerWidth;
        uniforms.u_resolution.value.y = window.innerHeight;
        // updateTesseractTextTexture();
      }
    }

    async function init() {
      await initHypercube();
      animate();
      initProgressBar();
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    window.addEventListener('resize', onWindowResize);
  </script>
</body>
</html>
